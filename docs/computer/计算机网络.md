# 网络概述

OSI是一种标准，TCP/IP是一种实现

## 一、OSI模型

`OSI`是`Open System Interconnection`，开放系统互联。

**`OSI`七层模型：**

7**应用层**(Application：为计算机用户提供接口和服务。

- 该层协议定义了`应用进程`之间的`交互规则`，通过不同的应用层协议为不同的`网络应用提供服务`。

6**表示层**(Presentation)：用于应用层数据的处理（编码解码、加密解密等）。

- 向下接受来自会话层的服务

- 使计算机内部的多种数据格式转换成通信中采用的标准表示形式

5**会话层**(Session)：管理（建立、维护、重连）**表示层实体之间的通信**会话。

- 表示层的通信由不同设备中的应用程序之间的服务请求和响应组成。

4**传输层**(Transport)：管理端到端的通信连接，定义传输数据的协议和端口号。

- 为**两台主机进程之间的通信**提供服务，处理`数据包错误`，`数据包次序`，以及其他一些关键传输问题。

3**网络层**(Network)：IP地址编址、数据路由（决定数据在网络中的路径）。

- 过寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。
- 网络层规定了数据包的**传输路线**，而传输层则规定了数据包的传输方式。

2**数据链路层**(Data Link)：管理相邻节点之间的数据通信、添加物理层地址(MAC地址，ARP)。

1**物理层**(Physical)：数据通信的光电物理特性，硬件相关。

程序开发人员需要考虑：应用层、表示层、会话层。

网络工程师需要考虑：运输层、网络层、数据链路层、物理层。

进行网络排错时：要从低层向高层来排错。

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207162209548.gif" alt="2021010409370574" />

## 二、TCP/IP模型

**`TCP/IP`四层模型：**

4**应用层**：传输数据单元（相当于OSI的765）。

- 通过不同的应用层协议为不同的应用提供服务

3**传输层**：传输层报文，TCP和UDP。

2**网络层**：IP数据报(IP分组)。

- 为分组网络中的主机提供通信服务，并通过`选择合适的路由`将数据传递到目标主机

1**链路层**：数据帧，物理地址寻址、光电特性（相当于OSI的12）又称网络接口层。

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207140922888.png" alt="图片" style="zoom:80%;" />

> TCP/IP协议蔟包括传输层、网络层、网络接口层（链路层）

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207192041722.png" alt="37689e1e3e374c74b351da9204c4da33" style="zoom:80%;" />

> TCP/IP 协议去掉表示层和会话层的原因在于会话层、表示层、应用层都是在应用程序内部实现的，最终产出的是一个应用数据包，而应用程序之间是几乎无法实现代码的抽象共享的
>
> 五层只是为了介绍网络原理设计的，实际还是四层。

## 三、性能指标

速率：**bps=bit/s**。 

QPS（TPS）= 并发数/平均响应时间

- 服务器每秒处理的事务数
- 峰值时间的每秒请求
- 每秒查询数

时延：发送时延、传播时延、排队时延、处理时延。 

往返时间RTT：数据报文在端到端通信中的来回一次的时间。

# Mac地址

网卡的物理地址，出厂自带，全球唯一。

局域网中的ip地址唯一，但是局域网外的可能重复。

网络通讯需要ip+mac，计算机通过**ARP协议**发送广播报文，只有相应的ip地址才会回复mac地址。

> 路由器与服务器通信时，通过**ARP协议**将ip地址转换成mac地址。

局域网中路由器通过DHCP协议分配不同的ip地址给设备。

**Mac地址是为了解决IP盗用的安全问题**

在交换机内部通过“表”的方式把MAC地址和IP地址一一对应，也就是所说的IP、MAC绑定。 

MAC地址处于链路层

### 同一网段下主机A ping 主机B的全过程 

同一网段下   没用到dns

ping 192.168.1.100(不知道对方的网卡地址 MAC) 

如何得到对方MAC地址(用arp协议)

1) A发送一个ARP广播包，询问192.168.1.100的MAC地址是多少
2) B回送ARP包，包中携带自己的MAC地址(00 50 A9 90 88 07) 
3) A记录ip地址，ARP表中(以后不用发送广播包)（可以不写）
4) A 发送一个icmp报文给B
5) B收到回送一个icmp报文 


# 交换机与路由器

## 一、交换机

交换机有若干端口，内部保存连接的网卡的mac与端口的对应关系，即MAC地址表。

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207081529012.png" alt="image-20220708152932145" style="zoom:50%;" />

## 二、路由器

路由器有WAN口和LAN口，

没有WAN口的话，就是个交换机

### 1、网关

连接两个子网

路由器也相当于一个网关

# Http状态码

https://www.runoob.com/http/http-status-codes.html

- 1xx：信息，服务器收到请求，需要请求者继续执行操作
- 2xx：成功，操作被成功接收并处理
	- 200 - 请求成功
- 3xx：重定向，需要进一步的操作以完成请求
	- 301 - 资源（网页等）被永久转移到其它URL
- 4xx：客户端错误，请求包含语法错误或无法完成请求
	
	- 401 - 请求要求用户的身份认证
	- 403 - 请求被拒绝（比如因为SSL，需要https访问）
	- 404 - 请求的资源（网页等）不存在
	- 408 -  服务器等待客户端发送的请求时间过长，超时
- 5xx：服务器错误，服务器在处理请求的过程中发生了错误
	- 500 - 服务器内部错误，无法完成请求
	- 503 - 服务器暂时处于超负载或正在进行停机维护，现在无法处理请求

# Socket网络编程

网络编程是是为了直接或间接地**通过网络协议与其它计算机实现数据交换**，进行通讯。

Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口（API）。**在应用层和传输层之间的一个抽象层。**在设计模式中，Socket其实就是一个门面模式，它`把复杂的TCP/IP协议族隐藏在Socket接口后面`，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。

- `网络上具有唯一标识的IP地址和端口号组合在一起构成唯一能识别的标识符套接字`
- 网络通信就是socket间的通信
- **socket允许程序把网络连接当成一个流，数据在两个socket间通过IO传输**
- 分类
	- 流套接字（stream socket）：使用TCP提供可依赖的字节流服务
	- 数据报套接字（datagram socket）：使用UDP提供“尽力而为”的数据报服务

TCP/IP协议族包括运输层、网络层、链路层。

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204051654646.png" alt="20190718154451958" style="zoom: 67%;" />

## 一、网络进程之间如何通信

- 首要解决的问题是**如何唯一标识一个进程**，否则通信无从谈起！在本地可以通过进程PID来唯一标识一个进程，但是在网络中这是行不通的。其实TCP/IP协议族已经帮我们解决了这个问题，网络层的“**ip地址**”可以唯一标识网络中的主机，而传输层的“**协议+端口**”可以唯一标识主机中的应用程序（进程）。
- 这样利用**三元组（ip地址，协议，端口）**就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。
- 使用TCP/IP协议的应用程序通常采用应用编程接口：UNIX BSD的套接字（socket）和UNIX System V的TLI（已经被淘汰），来实现网络进程之间的通信。就目前而言，几乎所有的应用程序都是采用socket。

## 二、socket的基本操作

网络中的进程是通过socket来通信的。

**socket允许程序把网络连接当成一个流，数据在两个socket间通过IO传输。**

socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用`“打开open –> 读写write/read –> 关闭close”`模式来操作。Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）。

## 三、基于Socket的TCP编程

Socket和ServerSocket用于建立TCP连接

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207211044052.png" alt="iShot_2022-07-21_10.43.15" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207211046023.png" alt="image-20220721104647366" style="zoom:50%;" />

## 四、基于Socket的UDP编程

发送端

```java
// 建立UDP连接
DatagramSocket ds = null; 
try {
    ds = new DatagramSocket();
    byte[] by = "hello,atguigu.com".getBytes(); 
    DatagramPacket dp = 
        new DatagramPacket(by, 0, by.length, InetAddress.getByName("127.0.0.1"), 10000); 
    ds.send(dp);
} catch (Exception e) { 
    e.printStackTrace();
} finally {
	if (ds != null)
        ds.close();
}
```

接收端

```java
DatagramSocket ds = null; 
try {
    // 指定监听的端口
	ds = new DatagramSocket(10000);
	byte[] by = new byte[1024];
	DatagramPacket dp = new DatagramPacket(by, by.length); 
    ds.receive(dp);
	String str = new String(dp.getData(), 0, dp.getLength()); 
    System.out.println(str + "--" + dp.getAddress());
} catch (Exception e) { 
    e.printStackTrace();
} finally {
    if (ds != null)
        ds.close();
}

```



<br>

# TCP和UDP

UDP是与TCP相对应的协议，都是是属于TCP/IP协议族中的一种。

- **TCP (Transmission Control Protocol) 传输控制协议**
	- 采用”三次握手“和”四次挥手机制“，建立TCP连接，形成传输数据通道，点对点通信，是**可靠的**
	- 在连接中可以进行**大数据量的传输**
	- 传输完毕，需要**释放已经建立的连接，效率低**
	- **面向连接**
	- 例如：电话
- **UDP (User Datagram Protocol) 用户数据报协议**
	- 每个数据报的大小限制在64K；可以广播发送
	- 发送不管对方是否收到，接收方收到也不确认，**不可靠**
	- 发送结束**无需释放资源**，**开销小**，**速度快**
	- **非面向连接**
	- 例如：短信，电报

<br>

# TCP的可靠性

TCP实现可靠传输依靠的有 **序列号**、**自动重传**、**滑动窗口**、**确认应答**等机制。

1. 应用数据被分割成 TCP 认为最适合发送的数据块。

2. TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。

3. **校验和**: TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。

4. TCP 的接收端会丢弃重复的数据。

5. **流量控制**: TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 

6. **拥塞控制**: 当网络拥塞时，减少数据的发送。

7. **ARQ**协议: 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。

8. **超时重传**: 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。 如果不能及时收到一个确认，将重发这个报文段。

	

## 序列号

TCP中将要发送的数据包的每个字节都分配了序列号，用来唯一标识一个字节。序列号随着数据包的发送而增加。

只有为每个字节分配一个序列号，每个数据包都对应着一个序列号区间，才能确定哪个数据包发送出现意外了。

序列号的初始化是由操作系统分配的，是一个32位的数字。

TCP初始化序列号不能设置为一个固定值，因为这样容易被攻击者猜出后续序列号，从而遭到攻击。

RFC1948中提出了一个较好的初始化序列号ISN随机生成算法。

```
ISN = M + F(localhost, localport, remotehost, remoteport)
```

M是一个计时器，这个计时器每隔4us加1。

F是一个随机算法，根据源IP、目的IP、源端口、目的端口生成一个随机数值。

## 自动重传ARQ

自动重传请求(Automatic Repeat-reQuest，ARQ)

当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。**如果不能及时收到一个确认，将重发这个报文段。**

自动重传有以下两个原因：

1、**数据包丢失**

2、**ack数据包丢失**

ARQ包括停止等待 ARQ 协议和连续 ARQ 协议。

### 停止等待ARQ协议

- 停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待 对方确认(回复ACK)。如果过了一段时间(超时时间后)，还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组; 

- 在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认;

### 连续ARQ协议

- 连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。

## 确认应答

当接收方收到一个数据包后，会直接返回一个ACK包，或者延迟一段时间返回一个ACK包，一次性确认多个数据包。

ACK包中有一个ack字段，代表着seq小于ack的数据包都已经被接收完毕。

## 滑动窗口

https://blog.csdn.net/qq_40276626/article/details/120230202

**滑动窗口** 分为 **发送窗口** 和 **接收窗口**。

**发送窗口** 用来 **发送数据**。

**接收窗口** 用来 **接收数据**。

**客户端和服务器端 都有**一个 **发送窗口** 和 **接收窗口**。

### 为什么会引入滑动窗口呢？

如果不存在发送窗口的话，TCP发送一个数据包后会等待ACK包，因为必须要保存对应的数据包，数据包很有可能需要重新发送。

这样的话发送效率会很慢。大部分时间都在等待。

> 滑动窗口解决的是**流量控制**的的问题，流量控制是为了控制发送方发送速率，保证接收方来得及接收。 

### 滑动窗口的机制

**只要处于发送窗口范围中的数据包都可以被发送，不需要等待前面数据包的ack包。**

如果发送窗口的大小为3个TCP数据包，那么发送方就可以连续发送3个TCP数据包，而不用等待前2个数据包的ack包。

1. 发送窗口只有收到发送窗口内字节的ACK确认，才会移动发送窗口的左边界。

2. 接收窗口只有在前面所有的段都确认的情况下才会移动左边界。当在前面还有字节未接收但收到后面字节的情况下，窗口不会移动，并不对后续字节确认。以此确保对端会对这些数据重传。

3. 遵循快速重传、累计确认、选择确认等规则。

4. 发送方发的window size = 8192；就是接收端最多发送8192字节，这个8192一般就是发送方接收缓存的大小。 

### 发送窗口

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207152003447.png" alt="c674184af4d64558b459128db6003944" style="zoom:50%;" />

### 接收窗口

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207152003044.png" alt="a4c7fdee43d8424d934f0edb4b405699" style="zoom:50%;" />

## 拥塞控制

在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。

拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。**拥塞控制是一个全局性的过程**，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。

为了进行拥塞控制，TCP 发送方要维持一个**拥塞窗口(cwnd)**的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。**发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。**

TCP的拥塞控制采用了四种算法，即 **慢开始** 、 **拥塞避免** 、**快重传** 和 **快恢复**。在网络层也可以 使路由器采用适当的分组丢弃策略(如主动队列管理 AQM)，以减少网络拥塞的发生。

- **慢开始**: 

	当主机开始发送数据时，还不知道网络的符合情况。较好的方法是先探测一下，即**由小到大逐渐增大发送窗口**，也就是由小到大逐渐增大拥塞窗口数值。 cwnd初始值为1，每经过一个传播轮次，cwnd加倍。

- **拥塞避免**: 

	拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1.

- **快重传与快恢复**:

	在 TCP/IP 中，快速重传和恢复(fast retransmit and recovery，FRR)是一种拥塞控制算法，它能**快速恢复丢失的数据包**。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。 有了 FRR，就不会因为重传时要求的暂停被耽误。  当有单独的数据包丢失时，快速重传和恢复(FRR)能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则 不能很有效地工作。

# Http与Https

http：

- 无加密、明文 
- —> 应用层

- 端口80

https：

- s【TLS标准，基于SSL(TLS前身)的加密协议】
- SSL在应用层和传输层之间加上了安全层
- —> 应用层 + 安全层
- 端口443

## 前言：SSL/TLS

[参考](https://blog.csdn.net/superfjj/article/details/105609565?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165839664216782246419541%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165839664216782246419541&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-105609565-null-null.142^v33^new_blog_pos_by_title,185^v2^control&utm_term=TLS&spm=1018.2226.3001.4187)

SSL/TLS是一种**安全通信框架**，他是世界上使用最广泛的**密码通信方法**。SSL/TLS综合运用了密码学中的对称密码，消息认证码，公钥密码，数字签名，伪随机数生成器等，可以说是密码学中的集大成者。

**SSL**(Secure Socket Layer)安全套接层，是1994年由Netscape公司设计的一套协议，并与1995年发布了3.0版本。

**TLS**(Transport Layer Security)传输层安全是IETF在SSL3.0基础上设计的协议，实际上相当于**SSL的后续版本**。

### TLS架构

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207211844166.png" alt="img" style="zoom:67%;" />

TLS记录协议：主要负责使用对称密码对消息进行加密。

TLS握手协议：主要分为握手协议，密码规格变更协议和应用数据协议4个部分。

- 握手协议负责在客户端和服务器端**商定密码算法和共享密钥**，包括证书认证，是4个协议中最最复杂的部分。
- 密码规格变更协议负责向通信对象**传达变更密码方式的信号**。
- 警告协议负责在发生错误的时候将错误传达给对方。
- 应用数据协议负责将TLS承载的应用数据传达给通信对象的协议。



## 一、对称加密和非对称加密

### 1、对称加密

加密和解密是同一把密钥

### 2、非对称加密

加密和解密使用不同的密钥

分公钥和私钥；使用公钥加密，则只能使用对应的私钥解密，私钥可以推出公钥，反之不行

SSL证书：保存在源服务器的数据文件，需向CA（Certificate Authority）申请，证书中包含公钥和私钥

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204061011366.PNG" />

公钥是传输的，私钥不传输，这样就算小黑想要窃取密文，也没有对应的密钥解开

## 二、https的加密(握手协议) — 对称与非对称共用

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204061016767.PNG" alt="IMG_1017 2" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207211854828.png" alt="img" style="zoom:80%;" />

第1随机数：客户端随机数；第2随机数：服务器随机数。

预设主密钥：用公钥加密后的随机数

使用会话密钥进行对称加密传输

> 传输对称加密的密钥（会话密钥）使用非对称加密
>
> 传输数据使用对称加密

## 三、认证

通过使用**证书**来对通信方进行认证。

数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。

服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。

进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202205011121645.png" width="" style="zoom:67%;" />

## 四、http1和http2

### 1、http1的缺陷

- 网络延迟问题主要由于**队头阻塞**(Head-Of-Line Blocking)，导致带宽无法被充分利用。

> 队头阻塞是指当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，会导致客户端迟迟收不到数据。

- 明文传输
- header中的固定字段会带来极大开销

### 2、区别

与HTTP 1.1相比，主要区别包括

a>HTTP/2采用**二进制格式**而非文本格式，虽然也是明文但是是二进制的；而且http2都是https协议的

b>HTTP/2是**完全多路复用**的，而非有序并阻塞的——只需一个连接即可实现并行

> 多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也接更容易实现全速传输，毕竟新开一个 TCP 连接都需要慢慢提升传输速度。

c>使用**报头压缩**，HTTP/2降低了开销

> 在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，还采用哈夫曼编码来压缩整数和字符串

d>HTTP/2让服务器可以将响应**主动“推送”**到客户端缓存中

> HTTP2还在一定程度上改变了传统的“请求-应答”工作模式，服务器不再是完全被动地响应请求，也可以新建“流”主动向客户端发送消息。比如，在浏览器刚请求HTML的时候就提前把可能会用到的JS、CSS文件发给客户端，减少等待的延迟，这被称为"服务器推送"（ Server Push，也叫 Cache push）

### 3、纯文本和二进制格式

ASCII模式（文本传输）和BINARY模式（二进制传输）

> 区别是回车换行的处理，binary方式不对数据执行任何处理，ASCII 方式将回车换行转换为本机的回车字符，比如Unix下 是\n,Windows下是\r\n，Mac下是\r

http1的文本格式是指它的请求头、响应头，分隔符等都是以文本方式传输的。

> 无符号数字123，用二进制的方式是直接发送一个字节，该字节内容是123。用纯文本的方式需要发送三个字节，内容是49 50 51，接收方收到之后可以解析为字符串`123`，在根据字符串`123`转为数字123

## 五、http3（QUIC）

[参考1](https://blog.csdn.net/weixin_45583158/article/details/106132325?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165839094116782350812518%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165839094116782350812518&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-4-106132325-null-null.142^v33^new_blog_pos_by_title,185^v2^control&utm_term=http3&spm=1018.2226.3001.4187)

[参考2](https://zhuanlan.zhihu.com/p/431672713)

基于TCP实现的HTTP2遗留下3个问题：

- 有序字节流引出的**队头阻塞**，使得HTTP2的多路复用能力大打折扣；
- **TCP与TLS叠加了握手时延**；
- 基于TCP四元组确定一个连接，这种诞生于有线网络的设计，并不适合移动状态下的无线网络，这意味着**IP地址的频繁变动会导致TCP连接、TLS会话反复握手，**成本高昂。

HTTP3协议解决了这些问题：

- HTTP3**基于UDP协议**重新定义了连接，在**QUIC层实现了无序、并发字节流的传输**，解决了队头阻塞问题（包括基于QPACK解决了动态表的队头阻塞）；
- HTTP3**重新定义了TLS协议加密QUIC头部的方式**，既提高了网络攻击成本，又降低了建立连接的速度（仅需1个RTT就可以同时完成建链与密钥协商）；

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207211635544.png" alt="img" style="zoom:80%;" />

> http2的网络层使用的是 TCP 协议， 而 HTTP3 的网络层使用的是**基于 UDP 修改的quic 协议**
>
> QUIC整合了TCP的可靠性和UDP的速度和效率

> 一条 **TCP** 连接是由**四元组**标识的，分别是**源 IP**、**源端口**、**目的 IP**、**目的端口**。一旦一个元素发生变化时，就需要断开重连，重新连接。在移动互联情况下，当手机信号不稳定或者在 WIFI 和 移动网络切换时，都会导致重连，从而进行再次的三次握手，导致一定的时延。
> 而**QUIC不再以四元组标识**，而是以一个 64 位的随机数作为 ID 来标识，而且 UDP 是无连接的，所以当 **IP 或者端口变化的时候**，**只要 ID 不变**，**就不需要重新建立连接**。

> 为了实现可靠性，QUIC 也有个序列号，是递增的。任何一个序列号的包只发送一次，下次就要加一了。即使丢包重传，序列号也会加一，并且QUIC 定义了一个 offset 概念。QUIC 既然是面向连接的，也就像 TCP 一样，是一个数据流，发送的数据在这个数据流里面有个偏移量 offset，可以通过 offset 查看数据发送到了哪里，这样只要这个 offset 的包没有来，就要重发；如果来了，按照 offset 拼接，还是能够拼成一个流。

> 为了防止网络上的中间设备识别协议的细节，QUIC 全面采用加密通信，而且QUIC 直接应用了 TLS1.3，顺便也就获得了 0-RTT、1-RTT 连接的好处。但 QUIC 并不是建立在 TLS 之上，而是内部“包含”了 TLS。它使用自己的帧“接管”了TLS 里的“记录”，握手消息、警报消息都不使用 TLS 记录，直接封装成 QUIC 的帧发送，省掉了一次开销。

> TCP 的流量控制是通过滑动窗口协议。而QUIC 的流量控制也是通过 window_update，来告诉对端它可以接受的字节数。但是 QUIC 的窗口是适应自己的多路复用机制的，不但在一个连接上控制窗口，还在一个连接中的每个 stream 控制窗口。

> HTTP3 没有指定默认的端口号，也就是说不一定非要在 UDP 的 80 或者 443 上提供 HTTP/3 服务。
> HTTP3 通过 HTTP2 里的“扩展帧”了。浏览器需要先用 HTTP2 协议连接服务器，然后服务器可以在启动 HTTP2 连接后发送一个“Alt-Svc”帧，包含一个“h3=host:port”的字符串，告诉浏览器在另一个端点上提供等价的 HTTP/3 服务。浏览器收到“Alt-Svc”帧，会使用 QUIC 异步连接指定的端口，如果连接成功，就会断开HTTP2 连接，改用新的HTTP3 收发数据。





## 六、HTTP协议的长连接和短连接

**HTTP协议的⻓连接和短连接，实质上是TCP协议的⻓连接和短连接。**

在HTTP/1.0中默认使用短连接。客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。

从HTTP/1.1起，默认使用⻓连接，用以保持连接特性。使用⻓连接的HTTP协议，会在响应头加入这行代码: `Connection:Keep-alive`。

> 在HTTP1.1中新增了24个错误状态响应码，如409(Conflict)表示请求的资源与资源的当前状态发生冲突；410(Gone)表示服务器上的某个资源被永久性的删除。

长连接有一个**保持时间**，可以在不同的服务器软件(如Apache)中设定这 个时间。实现⻓连接需要客户端和服务端都支持⻓连接。

## 七、http无状态，如何保存用户状态

HTTP 协议自身不对请求和响 应之间的通信状态进行保存。使用session通过服务端记录用户状态。

session保存在服务端，可以通过redis保存。

客户端通过在cookie中加入sessionID来告知服务端是哪个session。

> cookie禁用怎么办？
>
> 利用 URL 重写把 Session ID 直接附加在URL路径的后面。

<br>

# 各种协议与HTTP协议之间的关系

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207162241892.png" alt="image-20220716224100015" style="zoom:50%;" />

# 输入URL后的过程***

1. DNS解析成ip地址
2. 建立TCP连接
3. 浏览器发送HTTP请求

4. 服务器处理请求并返回HTTP报文

	> 还可以详细描述，服务器收到请求后，根据指定端口，将请求传递给绑定了该端口的应用程序，比如8080的tomcat；
	>
	> 收到请求后，解析得到需要访问的servlet，然后MVC的DispatcherServlet，Controller；
	>
	> tomcat得到响应后封装成http响应的格式，发送给浏览器所在的服务器。

5. 浏览器页面渲染

4. 断开连接

# URL和URI的区别

- URI(Uniform Resource Identifier) 是统一资源**标志符**，可以唯一标识一个资源。
-  URL(Uniform Resource Location) 是统一资源**定位符**，可以提供该资源的路径。它是一种**具 体的URI**，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。

URI的作用像身份证号一样，URL的作用更像家庭住址一样。

# DNS解析

浏览器希望得到**域名对应的ip地址**，DNS (Domain Name System，域名系统) 负责查找，查找过程如下：

1. 浏览器缓存中查找
2. 在系统缓存中查找，找系统的DNS缓存，即hosts文件中域名与ip的映射关系
3. 如在操作系统中没有找到，则查找本地DNS服务器缓存
4. 若本地DNS服务器中没有找到，直接请求Root Server域名服务器（根域名服务器）
5. Root Server接到请求后返回给本地DNS服务器一个gTLD server(顶级域名服务器||查询域的主域名服务器)地址
6. 本地DNS服务器用Root Server返回的gTLD server地址找到gTLD server并发出解析请求
7. gTLD 服务器接受了请求，并且进行处理（查找并且返回此域名对应的Name Server），说：“发现了，这个域名对应的Name服务器（域名服务器），你去找他要IP地址吧！”
8. 本地DNS服务器向Name Server发出解析的请求，Name Server找到该域名的IP，连同一个TTL值返回给本地DNS服务器
9. 欣喜的本地DNS服务器，立马缓存该域名和IP的对应关系（去到别人家的路线图），缓存的时间由TTL的值控制，心想：“我终于要完成任务了，我的主人马上就能去到这个域名的家里做客了！我拿到了去那里的路线图”
10. 把解析结果返回给用户，用户根据TTL的值进行缓存。



<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204060943604.png" alt="iShot2022-04-06_09.42.36" style="zoom:50%;" />

根域名服务器：.（root会省略，就是个点了）

顶级域名服务器gTLD：generic Top Level Domain

- com、cn、net、...

# CDN

https://blog.csdn.net/zhaohong_bo/article/details/89574459

https://blog.csdn.net/sshuai131400/article/details/121111209?ops_request_misc=&request_id=&biz_id=102&utm_term=cdn&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-121111209.nonecase&spm=1018.2226.3001.4187

Content Delivery Network，内容分发网络；用来提高访问速度

1. 为同一个主机配置多个ip入口
2. 把请求引导到不同的服务器上去——根据每台机器的负载量、该机器距离用户的地理位置距离

CDN = 更智能的镜像+缓存+流量导流

# TCP连接---三握四挥

因为TCP是全双工，连接和断开都需要确认

## 数据包

序列号**seq**：sequence；序列号seq就是这个报文段中的第一个字节的数据编号

确认号**ack**：期待收到对方下一个报文段的第一个数据字节的序号

控制位

- URG：紧急指针是否有效。为1，表示某一位需要被优先处理
- **ACK**：1表示确认号有效；Acknowledge
- PSH：提示接收端应用程序立即从TCP缓冲区把数据读走。
- RST：对方要求重新建立连接，复位。
- **SYN**：同步序号，1表示请求连接；SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。；Synchronization
- **FIN**：释放连接；Finish

PS：ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序号。

## 一、三次握手

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204051742823.png" alt="0E9867A3C4B032B2E9EA1AEA39867481" />

- 客户端发送SYN同步包（seq=x）到服务器，等待服务器确认；
- 服务器收到SYN包，必须确认客户的seq（使用ack=x+1，x为客户的seq），同时自己也发送一个SYN包（seq=y），即**SYN+ACK**包；
- 客户端收到服务器的SYN+ACK包，向服务器**发送确认包ACK**(ack=y+1），发送完成表示建立连接。

### 补充问题

1、传了SYN，为什么还要传ACK？

双方通信需要确保两者互发消息都无误。传回SYN，说明C到S到通道没问题；传ACK是为了验证S到C的通道有无问题。

## 二、四次挥手

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204051743057.png" alt="8EA876AC055FE582FBA4C7631E87A883"/>

四次挥手由于TCP的半关闭造成的，因为TCP是全双工，所以关闭时要双向都关闭，单方向的关闭叫做半关闭。

- **客户端进程发出连接释放报文FIN，并且停止发送数据**：客户端发送FIN，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1）。

	> TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。

- **服务器收到连接释放报文FIN，发出确认报文**，ACK=1，ack=u+1，以及序列号seq=v，等待关闭。

	> TCP服务器通知高层的应用进程，**客户端向服务器的方向就释放了**，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是**服务器可能依旧有数据没有发送完毕**。

- **客户端收到服务器的确认请求**后，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）

- **服务器将最后的数据发送完毕后，就向客户端发送连接释放报文FIN**，FIN=1，ack=u+1，假定此时的序列号为seq=w（由于在半关闭状态，服务器很可能又发送了一些数据），等待客户端的确认。

- **客户端收到服务器的连接释放报文后，发出确认**，ACK=1，ack=w+1，而自己的序列号是seq=u+1。

	> 注意此时TCP连接还没有释放，必须经过2MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
	>
	> TCB表存储每个活动TCP连接的控制*值。*

- 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。

## 常见问题

### 1、为什么连接的时候是三次握手，关闭的时候却是四次挥手？

连接时，客户端发送请求后，服务器可以直接发送SYN+ACK报文。但是关闭时，当服务器发送FIN后，服务器可能还有未发送完的数据，此时只能先发送一个ACK报文进行确认，等传输完成后，才会发送FIN报文。

### 2、为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？

虽然按道理，四个报文都发送完毕，可以直接进入CLOSE状态了，但是**必须假想网络是不可靠的**，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来**重发可能丢失的ACK报文**。

MSL是Maximum Segment Lifetime，最大报文段生存时间，2个MSL是报文段发送和接收的最长时间。

假定网络不可靠，那么第四次发送的ACK可能丢失，即B端无法收到这个ACK，如果B端收不到这个确认ACK，B端会定时向A端重复发送FIN，直到B端收到A的确认ACK。所以这个2MSL就是用来处理这个可能丢失的ACK的。而且能确保下一个新的连接中没有这个旧连接的报文。


### 3、为什么不能用两次握手进行连接？

3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。

现在把三次握手改成仅需要两次握手，死锁是可能发生的，还可能浪费资源。

#### 例子一：S认为建立了连接，但是C认为没有

考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发送了确认应答。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据。

可是，**在S的应答在传输中被丢失的情况下**，C将不知道S是否已准备好，甚至怀疑S是否收到自己的连接请求。

在这种情况下，**C认为连接还未建立成功**，**将忽略S发来的任何数据**，只等待连接确认应答。而S在发出的报文段超时后，重复发送同样的报文段。这样就形成了死锁。

#### 例子二：C的请求滞留，S认为滞留的是新请求，但是C不接收了

如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。

数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，**但是第一个丢失的报文段只是在某些网络结点长时间滞留了**，**延误到连接释放以后的某个时间才到达服务端**。

此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接。

不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。


### 4、如果已经建立了连接，但是客户端突然出现故障了怎么办？

TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

### 5、什么时候四次挥手可以变成三次？

如果客户端请求关闭连接时，服务器并没有数据需要发送，其实三次挥手应该也是可以的。
