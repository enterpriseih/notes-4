# 网络概述

OSI是一种标准，TCP/IP是一种实现

## 一、OSI模型

`OSI`是`Open System Interconnection`，开放系统互联。

![osi七层模型](https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202208161129225.png)

**`OSI`七层模型：**

7**应用层**(Application：为计算机用户提供接口和服务。

- 该层协议定义了`应用进程`之间的`交互规则`，通过不同的应用层协议为不同的`网络应用提供服务`。

6**表示层**(Presentation)：用于应用层数据的处理（编码解码、加密解密等）。

- 向下接受来自会话层的服务

- 使计算机内部的多种数据格式转换成通信中采用的标准表示形式

5**会话层**(Session)：管理（建立、维护、重连）**表示层实体之间的通信**会话。

- 表示层的通信由不同设备中的应用程序之间的服务请求和响应组成。

4**传输层**(Transport)：管理端到端的通信连接，定义传输数据的协议和端口号。

- 为**两台主机进程之间的通信**提供服务，处理`数据包错误`，`数据包次序`，以及其他一些关键传输问题。

3**网络层**(Network)：IP寻址、路由选择（决定数据在网络中的路径）。

- 过寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。
- 网络层规定了数据包的**传输路线**，而传输层则规定了数据包的传输方式。

2**数据链路层**(Data Link)：负责建立和管理节点间的链路

- 将数据封装成帧，进行可靠传输、添加物理层地址(MAC地址，ARP)。

1**物理层**(Physical)：比特流传输（光电特性）。

程序开发人员需要考虑：应用层、表示层、会话层。

网络工程师需要考虑：运输层、网络层、数据链路层、物理层。

进行网络排错时：要从低层向高层来排错。

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207162209548.gif" alt="2021010409370574" />

### 应用层协议

#### POP3/IMAP:邮件接收的协议

SMTP 协议只负责邮件的**发送**，真正负责**接收**的协议是POP3/IMAP。  

#### FTP:文件传输协议

**FTP 协议** 主要提供文件传输服务，基于 TCP 实现可靠的传输。使用 FTP 传输文件的好处是可以屏蔽操作系统和文件存储方式。

FTP 是基于客户—服务器（C/S）模型而设计的，在客户端与 FTP 服务器之间建立两个连接。

> FTP 的独特的优势同时也是与其它客户服务器程序最大的不同点就在于它在两台通信的主机之间使用了两条 TCP 连接（其它客户服务器应用程序一般只有一条 TCP 连接）：
>
> 1. 控制连接：用于传送控制信息（命令和响应）
> 2. 数据连接：用于数据传送；
>
> 这种将命令和数据分开传送的思想大大提高了 FTP 的效率。

![FTP工作过程](https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202208161133859.png)

#### Telnet:远程登陆协议

**Telnet 协议** 通过一个终端登陆到其他服务器，建立在可靠的传输协议 TCP 之上。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用Telnet并被一种称为SSH的非常安全的协议所取代的主要原因。

#### SSH:安全的网络传输协议

**SSH（ Secure Shell）** 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH  建立在可靠的传输协议 TCP 之上。

**Telnet 和 SSH 之间的主要区别在于 SSH 协议会对传输的数据进行加密保证数据安全性。**

![TCP和UDP](https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202208161134943.png)

## 二、TCP/IP模型

**`TCP/IP`四层模型：**

4**应用层**：传输数据单元（相当于OSI的765）。

- 通过不同的应用层协议为不同的应用提供服务

3**传输层**：传输层报文，TCP和UDP。

2**网络层**：IP数据报(IP分组)。

- 为分组网络中的主机提供通信服务，并通过`选择合适的路由`将数据传递到目标主机

1**链路层**：数据帧，物理地址寻址、光电特性（相当于OSI的12）又称网络接口层。

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207140922888.png" alt="图片" style="zoom:80%;" />

> TCP/IP协议蔟包括传输层、网络层、网络接口层（链路层）

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207192041722.png" alt="37689e1e3e374c74b351da9204c4da33" style="zoom:80%;" />

> TCP/IP 协议去掉表示层和会话层的原因在于会话层、表示层、应用层都是在应用程序内部实现的，最终产出的是一个应用数据包，而应用程序之间是几乎无法实现代码的抽象共享的
>
> 五层只是为了介绍网络原理设计的，实际还是四层。

### 为什么分层？

- 大部分软件系统都是分层架构的，为了工程上**实现/调试/维护方便**。网络系统分得更明显一点，因为其系统设计写成了协议。

- 把TCP/IP层次化是有好处的。比如，如果互联网只由一个协议统筹，某个地方需要改变设计时，就必须把所有部分整体替换掉。而分层之后只需把变动的层替换掉即可。把各层之间的接口部分规划好之后，每个层次内部的设计就能够自由改动了。

## 三、性能指标

速率：**bps=bit/s**。 

QPS（TPS）= 并发数/平均响应时间

- 服务器每秒处理的事务数
- 峰值时间的每秒请求
- 每秒查询数

时延：发送时延、传播时延、排队时延、处理时延。 

往返时间RTT：数据报文在端到端通信中的来回一次的时间。

## 四、数据链路层的数据传输

https://blog.csdn.net/m0_45861545/article/details/125785073

# 三大报文段

### UDP报文段

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202208081602674.png" alt="udp" style="zoom:80%;" />

### TCP报文段

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202208081556621.png" alt="tcp" style="zoom:80%;" />

### IP报文段

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202208081603712.png" alt="ip" style="zoom:80%;" />

### IP报文和TCP报文的关系

组合关系，消息：ip头部 + tcp头部 + 数据

ip报文 = ip头部 + ip报文数据

ip报文数据 = tcp头部 + tcp报文数据 = tcp报文

# IP地址

（1）分类

**IPv4**：4个字节（32位），4个0～255，如192.168.0.1

**IPv6**：16个字节（128位），写成8个无符号整数，每个整数用四个十六进制位表示， 数之间用冒号(:)分开，如:3ffe:3201:1401:1280:c8ff:fe4d:db39:1984

（2）[子网掩码](./子网掩码.md)



# Mac地址

网卡的物理地址，出厂自带，全球唯一。

局域网中的ip地址唯一，但是局域网外的可能重复。

> 同一时刻，同一个IP只会分给一个mac，但是断网之后，这个ip可能会分给别的mac

网络通讯需要ip+mac，计算机通过**ARP协议**发送广播报文，只有相应的ip地址才会回复mac地址。

> 路由器与服务器通信时，通过**ARP协议**将ip地址转换成mac地址。

局域网中路由器通过DHCP协议分配不同的ip地址给设备。

**Mac地址是为了解决IP盗用的安全问题**

在交换机内部通过“表”的方式把MAC地址和IP地址一一对应，也就是所说的IP、MAC绑定。 

MAC地址处于链路层

### 主机A与B通信： 同一网段下主机A ping 主机B的全过程 

A：192.168.0.3，B：192.168.0.1

1. **主机A广播发送ARP请求**，希望得到网关的MAC地址。

2. 交换机收到ARP请求，并**转发给连接到交换机的各个主机**。同时，**交换机更新它的MAC地址和端口映射表**，即将192.168.0.3绑定它所连接的端口。
3. 网关收到A的ARP请求后，**发出带有自身MAC地址的ARP响应**。网关更新ARP缓存表，**绑定A的IP地址和MAC地址**。
4. 交换机收到网关对A的ARP响应，查找MAC地址和端口映射表，并**将响应数据包发送到相应端口**。**交换机更新MAC地址和端口之间的映射表**，将192.168.0.1绑定它连接的端口。
5. **主机A收到ARP响应**，更新ARP缓存。
6. **主机A使用更新后的MAC地址信息把数据发送给网关**，通信通道就此建立。

# 交换机与路由器

## 一、交换机

交换机有若干端口，内部保存连接的网卡的mac与端口的对应关系，即MAC地址表。

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207081529012.png" alt="image-20220708152932145" style="zoom:50%;" />

## 二、路由器

路由器有WAN口和LAN口，

没有WAN口的话，就是个交换机

### 1、网关

连接两个子网

路由器也相当于一个网关

# Http状态码

https://www.runoob.com/http/http-status-codes.html

- 1xx：信息，服务器收到请求，需要请求者继续执行操作
- 2xx：成功，操作被成功接收并处理
	- 200 - 请求成功
- 3xx：重定向，需要进一步的操作以完成请求
	- 301 - 资源（网页等）被永久转移到其它URL
- 4xx：客户端错误，请求包含语法错误或无法完成请求
	
	- 401 - 请求要求用户的身份认证
	- 403 - 请求被拒绝（比如因为SSL，需要https访问）
	- 404 - 请求的资源（网页等）不存在
	- 408 -  服务器等待客户端发送的请求时间过长，超时
- 5xx：服务器错误，服务器在处理请求的过程中发生了错误
	- 500 - 服务器内部错误，无法完成请求
	- 503 - 服务器暂时处于超负载或正在进行停机维护，现在无法处理请求

# Socket网络编程

网络编程是是为了直接或间接地**通过网络协议与其它计算机实现数据交换**，进行通讯。

Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口（API）。**在应用层和传输层之间的一个抽象层。**在设计模式中，Socket其实就是一个门面模式，它`把复杂的TCP/IP协议族隐藏在Socket接口后面`，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。

- `网络上具有唯一标识的IP地址和端口号组合在一起构成唯一能识别的标识符套接字`
- 网络通信就是socket间的通信
- **socket允许程序把网络连接当成一个流，数据在两个socket间通过IO传输**
- 分类
	- 流套接字（stream socket）：使用TCP提供可依赖的字节流服务
	- 数据报套接字（datagram socket）：使用UDP提供“尽力而为”的数据报服务

TCP/IP协议族包括运输层、网络层、链路层。

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204051654646.png" alt="20190718154451958" style="zoom: 67%;" />

## 一、网络进程之间如何通信

- 首要解决的问题是**如何唯一标识一个进程**，否则通信无从谈起！在本地可以通过进程PID来唯一标识一个进程，但是在网络中这是行不通的。其实TCP/IP协议族已经帮我们解决了这个问题，网络层的“**ip地址**”可以唯一标识网络中的主机，而传输层的“**协议+端口**”可以唯一标识主机中的应用程序（进程）。
- 这样利用**三元组（ip地址，协议，端口）**就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。
- 使用TCP/IP协议的应用程序通常采用应用编程接口：UNIX BSD的套接字（socket）和UNIX System V的TLI（已经被淘汰），来实现网络进程之间的通信。就目前而言，几乎所有的应用程序都是采用socket。

## 二、socket的基本操作

网络中的进程是通过socket来通信的。

**socket允许程序把网络连接当成一个流，数据在两个socket间通过IO传输。**

socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用`“打开open –> 读写write/read –> 关闭close”`模式来操作。Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）。

## 三、基于Socket的TCP编程

Socket和ServerSocket用于建立TCP连接

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207211044052.png" alt="iShot_2022-07-21_10.43.15" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207211046023.png" alt="image-20220721104647366" style="zoom:50%;" />

## 四、基于Socket的UDP编程

发送端

```java
// 建立UDP连接
DatagramSocket ds = null; 
try {
    ds = new DatagramSocket();
    byte[] by = "hello,atguigu.com".getBytes(); 
    DatagramPacket dp = 
        new DatagramPacket(by, 0, by.length, InetAddress.getByName("127.0.0.1"), 10000); 
    ds.send(dp);
} catch (Exception e) { 
    e.printStackTrace();
} finally {
	if (ds != null)
        ds.close();
}
```

接收端

```java
DatagramSocket ds = null; 
try {
    // 指定监听的端口
	ds = new DatagramSocket(10000);
	byte[] by = new byte[1024];
	DatagramPacket dp = new DatagramPacket(by, by.length); 
    ds.receive(dp);
	String str = new String(dp.getData(), 0, dp.getLength()); 
    System.out.println(str + "--" + dp.getAddress());
} catch (Exception e) { 
    e.printStackTrace();
} finally {
    if (ds != null)
        ds.close();
}

```



<br>

# TCP的拆包与粘包

[TCP的拆包与粘包](./TCP的拆包与粘包.md)

# TCP和UDP

UDP是与TCP相对应的协议，都是是属于TCP/IP协议族中的一种。

- **TCP (Transmission Control Protocol) 传输控制协议**
	- 基于**字节流**。会发生粘包拆包。
	- 只支持点对点通信。
	- 采用”三次握手“和”四次挥手机制“，建立TCP连接，形成传输数据通道，点对点通信，是**可靠的**
	- 在连接中可以进行**大数据量的传输**
	- 传输完毕，需要**释放已经建立的连接，效率低**
	- **面向连接**
	- 例如：电话
- **UDP (User Datagram Protocol) 用户数据报协议**
	- 基于**数据报**；每个数据报的大小限制在64K；
	- 可以**广播发送**：一对一，一对多，多对一，多对多。
	- 发送不管对方是否收到，接收方收到也不确认，**不可靠**
	- 发送结束**无需释放资源**，**开销小**，**速度快**
	- **非面向连接**
	- 例如：短信，电报

> 对比
>
> 1. **是否面向连接**：TCP三握四挥建立连接，UDP不需要
> 2. **是否可靠传输**：UDP发送后不管对方是否收到，接收方收到也不确认，不可靠；TCP可靠。
> 3. **是否有状态**：TCP会记录发送消息之后的状态，是否发送成功等，有状态；UDP不会，无状态。
> 4. **传输效率**：TCP效率比UDP低，因为要连接。
> 5. **传输形式**：TCP字节流，UDP基于报文。
> 6. **首部开销**：TCP首部20-60字节；UDP首部8字节。
> 7. **是否提供广播通信或多播服务**：TCP只支持点对点通信；UDP可以广播发送：一对一，一对多，多对一，多对多。

## 什么时候选择TCP、UDP

- **UDP 一般用于即时通信**，比如：语音、 视频 、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大。
- **TCP 用于对传输准确性要求特别高的场景**，比如文件传输、发送和接收邮件、远程登录等等。

## 使用 TCP 的协议有哪些?使用 UDP 的协议有哪些?

### 运行于 TCP 协议之上的协议：

1. **HTTP 协议** ：超文本传输协议（HTTP，HyperText Transfer Protocol)主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。
2. **HTTPS 协议** ：更安全的超文本传输协议(HTTPS,Hypertext Transfer Protocol Secure)，身披 SSL 外衣的 HTTP 协议
3. **FTP 协议**：文件传输协议 FTP（File Transfer Protocol），提供文件传输服务，**基于 TCP** 实现可靠的传输。使用 FTP 传输文件的好处是可以屏蔽操作系统和文件存储方式。
4. **SMTP 协议**：简单邮件传输协议（SMTP，Simple Mail Transfer Protocol）的缩写，**基于 TCP 协议**，用来发送电子邮件。注意 ：接受邮件的协议不是 SMTP 而是 POP3 协议。
5. **POP3/IMAP 协议**：POP3 和 IMAP 两者都是负责邮件接收的协议。
6. **Telent 协议**：远程登陆协议，通过一个终端登陆到其他服务器。被一种称为 SSH 的非常安全的协议所取代。
7. **SSH 协议** : SSH（ Secure Shell）是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 建立在可靠的传输协议 TCP 之上。

### 运行于 UDP 协议之上的协议：

1. **DHCP 协议**：动态主机配置协议，动态配置 IP 地址
2. **DNS 域名系统（DNS，Domain Name System）**：将人类可读的域名转换为机器可读的 IP 地址。 我们可以将其理解为专为互联网设计的电话薄。实际上 DNS 同时支持 UDP 和 TCP 协议。

<br>

# [TCP的可靠性](https://blog.csdn.net/littlewhitevg/article/details/108556663)

TCP实现可靠传输依靠的有 **序列号**、**自动重传**、**滑动窗口**、**确认应答**等机制。

1. 应用数据被分割成 TCP 认为最适合发送的数据块。

2. **数据编号**：TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。

3. **校验和**: TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。

4. TCP 的接收端会丢弃重复的数据。

5. **流量控制**: TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 

6. **拥塞控制**: 当网络拥塞时，减少数据的发送。

7. **ARQ**协议: 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。

8. **超时重传**: 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。 如果不能及时收到一个确认，将重发这个报文段。

	

## 序列号

TCP中将要发送的数据包的每个字节都分配了序列号，用来唯一标识一个字节。序列号随着数据包的发送而增加。

只有为每个字节分配一个序列号，每个数据包都对应着一个序列号区间，才能确定哪个数据包发送出现意外了。

序列号的初始化是由操作系统分配的，是一个32位的数字。

TCP初始化序列号不能设置为一个固定值，因为这样容易被攻击者猜出后续序列号，从而遭到攻击。

RFC1948中提出了一个较好的初始化序列号ISN随机生成算法。

```
ISN = M + F(localhost, localport, remotehost, remoteport)
```

M是一个计时器，这个计时器每隔4us加1。

F是一个随机算法，根据源IP、目的IP、源端口、目的端口生成一个随机数值。

## 自动重传ARQ

自动重传请求(Automatic Repeat-reQuest，ARQ)

当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。**如果不能及时收到一个确认，将重发这个报文段。**

自动重传有以下两个原因：

1、**数据包丢失**

2、**ack数据包丢失**

ARQ包括停止等待 ARQ 协议和连续 ARQ 协议。

### 停止等待ARQ协议

- 停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待 对方确认(回复ACK)。如果过了一段时间(超时时间后)，还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组; 

- 在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认;

### 连续ARQ协议

- 连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。

## 确认应答

当接收方收到一个数据包后，会直接返回一个ACK包，或者延迟一段时间返回一个ACK包，一次性确认多个数据包。

ACK包中有一个ack字段，代表着seq小于ack的数据包都已经被接收完毕。

## 流量控制：滑动窗口

https://blog.csdn.net/qq_40276626/article/details/120230202

端到端

**滑动窗口** 分为 **发送窗口** 和 **接收窗口**。

**发送窗口** 用来 **发送数据**。

**接收窗口** 用来 **接收数据**。

**客户端和服务器端 都有**一个 **发送窗口** 和 **接收窗口**。

### 为什么会引入滑动窗口呢？

如果不存在发送窗口的话，TCP发送一个数据包后会等待ACK包，因为必须要保存对应的数据包，数据包很有可能需要重新发送。

这样的话发送效率会很慢。大部分时间都在等待。

> 滑动窗口解决的是**流量控制**的的问题，流量控制是为了控制发送方发送速率，保证接收方来得及接收。 

### 滑动窗口的机制

**只要处于发送窗口范围中的数据包都可以被发送，不需要等待前面数据包的ack包。**

如果发送窗口的大小为3个TCP数据包，那么发送方就可以连续发送3个TCP数据包，而不用等待前2个数据包的ack包。

1. 发送窗口只有收到发送窗口内字节的ACK确认，才会移动发送窗口的左边界。

2. 接收窗口只有在前面所有的段都确认的情况下才会移动左边界。当在前面还有字节未接收但收到后面字节的情况下，窗口不会移动，并不对后续字节确认。以此确保对端会对这些数据重传。

3. 遵循快速重传、累计确认、选择确认等规则。

4. 发送方发的window size = 8192；就是接收端最多发送8192字节，这个8192一般就是发送方接收缓存的大小。 

### 发送窗口

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207152003447.png" alt="c674184af4d64558b459128db6003944" style="zoom:50%;" />

### 接收窗口

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207152003044.png" alt="a4c7fdee43d8424d934f0edb4b405699" style="zoom:50%;" />

## 拥塞控制

在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。

> 拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。

拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。**拥塞控制是一个全局性的过程**，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。

为了进行拥塞控制，TCP 发送方要维持一个**拥塞窗口(cwnd)**的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。**发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。**

TCP的拥塞控制采用了四种算法，即 **慢开始** 、 **拥塞避免** 、**快重传** 和 **快恢复**。在网络层也可以 使路由器采用适当的分组丢弃策略(如主动队列管理 AQM)，以减少网络拥塞的发生。

- **慢开始**: 

	当主机开始发送数据时，还不知道网络的符合情况。较好的方法是先探测一下，即**由小到大逐渐增大发送窗口**，也就是由小到大逐渐增大拥塞窗口数值。 cwnd初始值为1，每经过一个传播轮次，cwnd加倍。

- **拥塞避免**: 

	拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1.

- **快重传与快恢复**:

	在 TCP/IP 中，快速重传和恢复(fast retransmit and recovery，FRR)是一种拥塞控制算法，它能**快速恢复丢失的数据包**。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。 有了 FRR，就不会因为重传时要求的暂停被耽误。  当有单独的数据包丢失时，快速重传和恢复(FRR)能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则 不能很有效地工作。

# Http与Https

http：

- 无加密、明文 
- —> 应用层

- 端口80

https：

- s【TLS标准，基于SSL(TLS前身)的加密协议】
- SSL在应用层和传输层之间加上了安全层
- —> 应用层 + 安全层
- 端口443

## 前言：SSL/TLS

[参考](https://blog.csdn.net/superfjj/article/details/105609565?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165839664216782246419541%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165839664216782246419541&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-105609565-null-null.142^v33^new_blog_pos_by_title,185^v2^control&utm_term=TLS&spm=1018.2226.3001.4187)

SSL/TLS是一种**安全通信框架**，他是世界上使用最广泛的**密码通信方法**。SSL/TLS综合运用了密码学中的对称密码，消息认证码，公钥密码，数字签名，伪随机数生成器等，可以说是密码学中的集大成者。

**SSL**(Secure Socket Layer)安全套接层，是1994年由Netscape公司设计的一套协议，并与1995年发布了3.0版本。

**TLS**(Transport Layer Security)传输层安全是IETF在SSL3.0基础上设计的协议，实际上相当于**SSL的后续版本**。

### TLS架构

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207211844166.png" alt="img" style="zoom:67%;" />

TLS记录协议：主要负责使用对称密码对消息进行加密。

TLS握手协议：主要分为握手协议，密码规格变更协议和应用数据协议4个部分。

- 握手协议负责在客户端和服务器端**商定密码算法和共享密钥**，包括证书认证，是4个协议中最最复杂的部分。
- 密码规格变更协议负责向通信对象**传达变更密码方式的信号**。
- 警告协议负责在发生错误的时候将错误传达给对方。
- 应用数据协议负责将TLS承载的应用数据传达给通信对象的协议。



## 一、对称加密和非对称加密

### 1、对称加密

加密和解密是同一把密钥

### 2、非对称加密

[RSA加密算法](https://blog.csdn.net/w_rep/article/details/110136168)

加密和解密使用不同的密钥

分公钥和私钥；使用公钥加密，则只能使用对应的私钥解密，私钥可以推出公钥，反之不行

SSL证书：保存在源服务器的数据文件，需向CA（Certificate Authority）申请，证书中包含公钥和私钥

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204061011366.PNG" />

公钥是传输的，私钥不传输，这样就算小黑想要窃取密文，也没有对应的密钥解开

## 二、https的加密(握手协议) — 对称与非对称共用

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204061016767.PNG" alt="IMG_1017 2" style="zoom:80%;" />

大致步骤：

1. 客户端传客户端随机数（第1随机数），服务器传服务器随机数（第2随机数）

2. 服务器再传公钥

3. 客户端传用公钥加密后的随机数（预设主密钥），服务器用私钥解密

会话密钥 = 客户端随机数 + 服务器随机数 + 预设主密钥

> 传输对称加密的密钥（会话密钥）使用非对称加密
>
> 传输数据使用对称加密

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207211854828.png" alt="img" style="zoom:80%;" />

- 2的密码套件和压缩方式是对1的清单的回应。
- 没有3的话就得4
- 10和12是通知对方要切换到协商的密码了

## 三、认证

通过使用**证书**来对通信方进行认证。

数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。

服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。

进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202205011121645.png" width="" style="zoom:67%;" />

## 四、http无状态，如何保存用户状态

HTTP 协议自身不对请求和响 应之间的通信状态进行保存。使用session通过服务端记录用户状态。

session保存在服务端，可以通过redis保存。

客户端通过在cookie中加入sessionID来告知服务端是哪个session。

> cookie禁用怎么办？
>
> 利用 URL 重写把 Session ID 直接附加在URL路径的后面。



# Http123

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202208051503641.png" alt="image-20220805150314787" style="zoom:50%;" />

## Http/1.1比Http/1.0的改进

- **使用** **TCP** **长连接**的方式改善了 HTTP/1.0 短连接造成的性能开销。 

- **支持管道** (pipeline) 网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求 出去，可以减少整体的响应时间。

## http1和http2

### 1、http1的缺陷

- 网络延迟问题主要由于**队头阻塞**(Head-Of-Line Blocking)，导致带宽无法被充分利用。

> 队头阻塞是指当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，会导致客户端迟迟收不到数据。

- 明文传输。
- 发送冗长的首部header。每次互相发送相同的首部造成的浪费较多。

### 2、区别

与HTTP 1.1相比，主要区别包括

#### a>二进制格式

HTTP/2采用**二进制格式**而非文本格式，虽然也是明文但是是二进制的；而且http2都是https协议的

#### b>多路复用

HTTP/2 是可以在**一个连接中并发多个请求或回应，而不用按照顺序一一对应**。

> 举例来说，在一个 TCP 连接里，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程非常耗 时，于是就回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分。

#### c>报头压缩

使用**报头压缩**，HTTP/2降低了开销

如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会 帮你**消除重复的部分**。

> 在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，还采用哈夫曼编码来压缩整数和字符串

#### d>主动推送

HTTP/2让服务器可以将响应**主动“推送”**到客户端缓存中

> HTTP2还在一定程度上改变了传统的“请求-应答”工作模式，服务器不再是完全被动地响应请求，也可以新建“流”主动向客户端发送消息。比如，在浏览器刚请求HTML的时候就提前把可能会用到的JS、CSS文件发给客户端，减少等待的延迟，这被称为"服务器推送"（ Server Push，也叫 Cache push）

### 3、纯文本和二进制格式

ASCII模式（文本传输）和BINARY模式（二进制传输）

> 区别是回车换行的处理，binary方式不对数据执行任何处理，ASCII 方式将回车换行转换为本机的回车字符，比如Unix下 是\n,Windows下是\r\n，Mac下是\r

http1的文本格式是指它的请求头、响应头，分隔符等都是以文本方式传输的。

> 无符号数字123，用二进制的方式是直接发送一个字节，该字节内容是123。用纯文本的方式需要发送三个字节，内容是49 50 51，接收方收到之后可以解析为字符串`123`，在根据字符串`123`转为数字123

## http3（QUIC, Quick UDP Internet Connection）

基于TCP实现的HTTP2遗留下3个问题：

- **丢包引发的阻塞**：HTTP/2 主要的问题在于，多个 HTTP 请求在复用一个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的**所有的** **HTTP** **请求都必须等待这个丢了的包被重传回来**。
- **TCP与TLS叠加了握手时延**；
- 基于TCP四元组确定一个连接，这种诞生于有线网络的设计，并不适合移动状态下的无线网络，这意味着**IP地址的频繁变动会导致TCP连接、TLS会话反复握手，**成本高昂。

HTTP3协议解决了这些问题：

- HTTP3**基于UDP协议**重新定义了连接，在**QUIC层实现了无序、并发字节流的传输**，解决了队头阻塞问题（包括基于QPACK解决了动态表的队头阻塞）；
- HTTP3**重新定义了TLS协议加密QUIC头部的方式**，既提高了网络攻击成本，又降低了建立连接的速度（仅需1个RTT就可以同时完成建链与密钥协商）；

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207211635544.png" alt="img" style="zoom:80%;" />

QUIC的优点：

- **通过减少往返次数**，**缩短连接建立的时间**：QUIC只需要一次就可以建立连接。

- **独立的数据流避免阻塞问题**

- **改进的拥塞控制**

	TCP 的拥塞控制实际上包含了四个算法:慢启动，拥塞避免，快速重传，快速恢复。
	 QUIC 协议当前默认使用了 TCP 协议的 Cubic 拥塞控制算法，同时也支持 CubicBytes, Reno, RenoBytes, BBR, PCC 等拥塞控制算法

	FEC前向纠正拥塞控制

	FEC是Forward Error Correction前向错误纠正的意思，就是通过多发一些冗余的包，当有些包丢失时， 可以通过冗余的包恢复出来，而不用重传。这个算法在多媒体网关拥塞控制有重要的地位。QUIC的FEC 是使用的XOR的方式，即发N + 1个包，多发一个冗余的包，在正常数据的N个包里面任意一个包丢了， 可以通过这个冗余的包恢复出来，使用异或可以做到

- **更安全的传输协议**

	TCP 协议头部没有经过任何加密和认证，所以在传输过程中很容易被中间网络设备篡改，注入和窃听。 比如修改序列号、滑动窗口。这些行为有可能是出于性能优化，也有可能是主动攻击。

	QUIC 的 packet 除了个别报文比如 PUBLIC_RESET 和 CHLO，所有报文 头部都是经过认证的，报文 Body 都是经过加密的。

> http2的网络层使用的是 TCP 协议， 而 HTTP3 的网络层使用的是**基于 UDP 修改的quic 协议**
>
> QUIC整合了TCP的可靠性和UDP的速度和效率

> 一条 **TCP** 连接是由**四元组**标识的，分别是**源 IP**、**源端口**、**目的 IP**、**目的端口**。一旦一个元素发生变化时，就需要断开重连，重新连接。在移动互联情况下，当手机信号不稳定或者在 WIFI 和 移动网络切换时，都会导致重连，从而进行再次的三次握手，导致一定的时延。
> 而**QUIC不再以四元组标识**，而是以一个 64 位的随机数作为 ID 来标识，而且 UDP 是无连接的，所以当 **IP 或者端口变化的时候**，**只要 ID 不变**，**就不需要重新建立连接**。

[http3](./Http3.md)

## HTTP协议的长连接和短连接

**HTTP协议的⻓连接和短连接，实质上是TCP协议的⻓连接和短连接。**

在HTTP/1.0中默认使用短连接。客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。

从HTTP/1.1起，默认使用⻓连接，用以保持连接特性。使用⻓连接的HTTP协议，会在响应头加入这行代码: `Connection:Keep-alive`。

> 在HTTP1.1中新增了24个错误状态响应码，如409(Conflict)表示请求的资源与资源的当前状态发生冲突；410(Gone)表示服务器上的某个资源被永久性的删除。

长连接有一个**保持时间**，可以在不同的服务器软件(如Apache)中设定这 个时间。实现⻓连接需要客户端和服务端都支持⻓连接。

<br>

# Http和TCP

http是应用层协议，tcp是传输层协议

http是要基于tcp连接的基础上的

http用来收发数据，tcp只是用来建立连接

# 各种协议与HTTP协议之间的关系

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207162241892.png" alt="image-20220716224100015" style="zoom:50%;" />

# 输入URL后的过程***

1. DNS解析成ip地址
2. 建立TCP连接
3. 浏览器发送HTTP请求

4. 服务器处理请求并返回HTTP报文

	> 还可以详细描述，服务器收到请求后，根据指定端口，将请求传递给绑定了该端口的应用程序，比如8080的tomcat；
	>
	> 收到请求后，解析得到需要访问的servlet，然后MVC的DispatcherServlet，Controller；
	>
	> tomcat得到响应后封装成http响应的格式，发送给浏览器所在的服务器。

5. 浏览器页面渲染

4. 断开连接

# URL和URI的区别

- URI(Uniform Resource Identifier) 是统一资源**标志符**，可以唯一标识一个资源。
-  URL(Uniform Resource Location) 是统一资源**定位符**，可以提供该资源的路径。它是一种**具体的URI**，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。

URI的作用像身份证号一样，URL的作用更像家庭住址一样。

# DNS解析

浏览器希望得到**域名对应的ip地址**，DNS (Domain Name System，域名系统) 负责查找，查找过程如下：

1. 浏览器缓存中查找
2. 在系统缓存中查找，找系统的DNS缓存，即hosts文件中域名与ip的映射关系
3. 如在操作系统中没有找到，则查找本地DNS服务器缓存
4. 若本地DNS服务器中没有找到，直接请求Root Server域名服务器（根域名服务器）
5. Root Server接到请求后返回给本地DNS服务器一个gTLD server(顶级域名服务器||查询域的主域名服务器)地址
6. 本地DNS服务器用Root Server返回的gTLD server地址找到gTLD server并发出解析请求
7. gTLD 服务器接受了请求，并且进行处理（查找并且返回此域名对应的Name Server），说：“发现了，这个域名对应的Name服务器（域名服务器），你去找他要IP地址吧！”
8. 本地DNS服务器向Name Server发出解析的请求，Name Server找到该域名的IP，连同一个TTL值返回给本地DNS服务器
9. 欣喜的本地DNS服务器，立马缓存该域名和IP的对应关系（去到别人家的路线图），缓存的时间由TTL的值控制，心想：“我终于要完成任务了，我的主人马上就能去到这个域名的家里做客了！我拿到了去那里的路线图”
10. 把解析结果返回给用户，用户根据TTL的值进行缓存。



<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204060943604.png" alt="iShot2022-04-06_09.42.36" style="zoom:50%;" />

根域名服务器：.（root会省略，就是个点了）

顶级域名服务器gTLD：generic Top Level Domain

- com、cn、net、...

# CDN

https://blog.csdn.net/zhaohong_bo/article/details/89574459

https://blog.csdn.net/sshuai131400/article/details/121111209?ops_request_misc=&request_id=&biz_id=102&utm_term=cdn&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-121111209.nonecase&spm=1018.2226.3001.4187

https://mp.weixin.qq.com/s/bHGxezDzhYNSB7XV44CKtQ

Content Delivery Network，内容分发网络；用来提高访问速度

1. 为同一个主机配置多个ip入口
2. 把请求引导到不同的服务器上去——根据每台机器的负载量、该机器距离用户的地理位置距离

CDN = 更智能的镜像+缓存+流量导流

# TCP连接---三握四挥

因为TCP是全双工，连接和断开都需要确认

TCP报文段分为头部信息和数据

## TCP报文段

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202208081556621.png" alt="tcp" style="zoom:80%;" />



16位**端口号**：包括了源端口号和目的端口号。进行TCP通信时，客户端通常使用系统自动选择的临时端口号(一般都很大)，而服务器则使用知名服务端口号或服务器管理员自定义的端口号。

32位**序列号seq**：sequence；序列号seq就是这个报文段中的第一个字节的数据编号

32位**确认号ack**：对对方报文段作出回应。期待收到对方下一个报文段的第一个数据字节的序号，即对方传送的seq是本次传过去的ack。

4位头部长度（数据偏移）：TCP报文段的数据起始距离TCP报文段的起始处有多远。标识该tcp头部有多少个32bit字（4字节）因为4位最大能表示15，所以tcp头部最长是60字节。

6位**标记位**：

- URG：紧急指针是否有效。为1，表示某一位需要被优先处理
- **ACK**：1表示确认号有效；Acknowledge
- PSH：提示接收端应用程序立即从TCP缓冲区把数据读走。
- RST：对方要求重新建立连接，复位。
- **SYN**：同步序号，1表示请求连接；SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。；Synchronization
- **FIN**：释放连接；Finish

> Note：ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序号。

16位**窗口大小**：是TCP流量控制的一个手段。这里说的窗口指的是**接收窗口**(RWND)。它告诉对方本端TCP接收缓冲区还能容纳多少字节的数据，以让对方控制发送数据的速度。

16位**校验和**：由发送端填充，接收端对TCP报文段执行CRC算法以效验TCP报文段在传输过程中是否损坏(包括TCP头部和数据部分)。这也是TCP可靠传输的一个重要保障。

16位**紧急指针**：仅在 URG = 1时才有意义，它代表本报文段中的紧急数据的字节数(紧急数据结束后就是普通数据)，即指出**紧急数据在报文末尾的位置**（注意：及时窗口为0 时也可以发送紧急数据）

**选项**：长度可变，最长可达 40 字节，当没有使用选项时，TCP首部长度是 20 字节

## 一、三次握手

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204051742823.png" alt="0E9867A3C4B032B2E9EA1AEA39867481" />

- 客户端发送SYN同步包（seq=x）到服务器，等待服务器确认；
- 服务器收到SYN包，必须确认客户的seq（使用ack=x+1，x为客户的seq），同时自己也发送一个SYN包（seq=y），即**SYN+ACK**包；
- 客户端收到服务器的SYN+ACK包，向服务器**发送确认包ACK**(ack=y+1），发送完成表示建立连接。

### 补充问题

1、传了SYN，为什么还要传ACK？

双方通信需要确保两者互发消息都无误。传回SYN，说明C到S到通道没问题；传ACK是为了验证S到C的通道有无问题。

## 二、四次挥手

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204051743057.png" alt="8EA876AC055FE582FBA4C7631E87A883"/>

四次挥手由于TCP的半关闭造成的，因为TCP是全双工，所以关闭时要双向都关闭，单方向的关闭叫做半关闭。

- **客户端进程发出连接释放报文FIN，并且停止发送数据**：客户端发送FIN，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1）。

	> TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。

- **服务器收到连接释放报文FIN，发出确认报文**，ACK=1，ack=u+1，以及序列号seq=v，等待关闭。

	> TCP服务器通知高层的应用进程，**客户端向服务器的方向就释放了**，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是**服务器可能依旧有数据没有发送完毕**。

- **客户端收到服务器的确认请求**后，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）

- **服务器将最后的数据发送完毕后，就向客户端发送连接释放报文FIN**，FIN=1，ack=u+1，假定此时的序列号为seq=w（由于在半关闭状态，服务器很可能又发送了一些数据），等待客户端的确认。

- **客户端收到服务器的连接释放报文后，发出确认**，ACK=1，ack=w+1，而自己的序列号是seq=u+1。

	> 注意此时TCP连接还没有释放，必须经过2MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。为了防止陈旧报文影响后续报文。
	>
	> TCB表存储每个活动TCP连接的控制*值。*

- 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。

## 常见问题

### 1、为什么连接的时候是三次握手，关闭的时候却是四次挥手？

连接时，客户端发送请求后，服务器可以直接发送SYN+ACK报文。但是关闭时，当服务器发送FIN后，服务器可能还有未发送完的数据，此时只能先发送一个ACK报文进行确认，等传输完成后，才会发送FIN报文。

### 2、为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？

虽然按道理，四个报文都发送完毕，可以直接进入CLOSE状态了，但是**必须假想网络是不可靠的**，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来**重发可能丢失的ACK报文**。

MSL是Maximum Segment Lifetime，最大报文段生存时间，2个MSL是报文段发送和接收的最长时间。

假定网络不可靠，那么第四次发送的ACK可能丢失，即B端无法收到这个ACK，如果B端收不到这个确认ACK，B端会定时向A端重复发送FIN，直到B端收到A的确认ACK。所以这个2MSL就是用来处理这个可能丢失的ACK的。而且能确保下一个新的连接中没有这个旧连接的报文。


### 3、为什么不能用两次握手进行连接？

3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。

现在把三次握手改成仅需要两次握手，死锁是可能发生的，还可能浪费资源。

#### 例子一：S认为建立了连接，但是C认为没有

考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发送了确认应答。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据。

可是，**在S的应答在传输中被丢失的情况下**，C将不知道S是否已准备好，甚至怀疑S是否收到自己的连接请求。

在这种情况下，**C认为连接还未建立成功**，**将忽略S发来的任何数据**，只等待连接确认应答。而S在发出的报文段超时后，重复发送同样的报文段。这样就形成了死锁。

#### 例子二：C的请求滞留，S认为滞留的是新请求，但是C不接收了

如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。

数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，**但是第一个丢失的报文段只是在某些网络结点长时间滞留了**，**延误到连接释放以后的某个时间才到达服务端**。

此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接。

不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。


### 4、如果已经建立了连接，但是客户端突然出现故障了怎么办？

TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

### 5、什么时候四次挥手可以变成三次？

如果客户端请求关闭连接时，服务器并没有数据需要发送，其实三次挥手应该也是可以的。

### 6、SYN洪泛攻击如何解决？ 

攻击者伪装成客户端发送TCP的SYN报文，当服务器返回ACK确认报文之后，攻击者不再进行确认，即不回复确认的确认报文，这个连接就处于一个挂起的状态，服务器收不到确认报文的话，会启用超时重传机制，重复发送ACK给攻击者 

如果攻击者开启大量这种TCP连接，导致服务器端有很多个挂起的连接，并且需要重复发送很多ACK给攻击者，这样就会消耗服务器的内存，可能导致最后服务器死机，无法正常工作 

 **解决方法** 

-  **降低SYN timeout时间** 使得服务器在没收到确认报文后尽快释放半连接的占用 
-  **采用SYN cookie设置** 给每一个请求连接的ip地址分配一个cookie，短时间内如果连续收到某个IP的重复的SYN报文，就认定收到了攻击，以后会自动丢弃该ip地址传送过来的包

### 7、第三次握手的作用

第一、二次握手后，服务端并不知道客户端的接受能力以及自己的发送能力是否正常，而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了，所以，**服务端的发送能力是正常的**。而**客户端的接收能力也是正常的**。



## 常用端口号

redis：6379

mysql：3306

tomcat：8080

http/nginx：80

nacos：8848
