# 秒杀系统

特点：瞬时流量大，秒杀商品库存少，静态资源访问多（秒杀时间来临前刷新量大）

1. 高并发

2. 防止超卖：大量并发扣减库存，导致库存变负。

3. 防刷子：恶意刷单等，抢占订单。限流。

4. 页面资源访问多：考虑页面静态化，CDN，静态资源缓存及压缩。

5. 秒杀按钮：通过前端按钮置灰。

6. 秒杀真链接隐藏：防止后台交互链接，非秒杀期间漏出。

7. 异步处理订单后续：秒杀成功后，订单处理交于异步服务。

8. 订单失败补偿：遇到订单后续处理失败，必须补偿。

9. 服务降级：遇到紧急情况，可以快速处理。



### 1、针对高并发

上线前做好测压，知道服务qps瓶颈点，针对日常业务秒杀多预估，进行服务器多准备。

测量tps，寻找薄弱点进行代码优化，服务支撑优化。

一般采用redis+热数据+mq，集群负载均衡。前端静态化+cdn加速。

### 2、防止超卖

秒杀前，将库存同步到redis。

借助分布式锁和lua脚本来保证库存扣减的原子性。

### 3、限流防刷子

一种是用户ID限流，一种是ip进行限流。

### 4、页面资源静态化

url唯一化处理，对页面资源提前进行缓存，保证用户直接请求url对时候，无需去解析请求头，无需重组http协议，可直接找到静态资源进行返回，不与后端做数据交互。

一般静态化要放在cdn上，cdn的就近原则可以提高响应速度和命中率。

同时cdn开启资源压缩，减少传输速度。

### 5、秒杀真链接隐藏

防止刷子在秒杀开始之前知道真正的请求链接，通过机器等方式进行提前请求。

采取链接加密，每次秒杀都无规律可言，只有时间到了才能看到真实的秒杀地址。

### 6、异步处理订单

消息队列

用户参与秒杀成功后，不应该同步返回用户秒杀结果，而是交给消息队列，交由其他服务进行后续的负责处理，直接返回给用户秒杀成功。

随着用户点击查看订单的过程，后端其实已经处理完毕。

### 7、服务降级

下下策。

由于服务确实出现了问题，导致秒杀业务不能正常进行。比如，秒杀价格错误。

为了及时止损，要做一个降级开关，不做任何交互，直接返回一些提示文案（比如，秒杀结束）。

还有可能是服务器撑不住了，也需要进行降级。



# 短链系统

https://blog.csdn.net/weixin_42754896/article/details/126024740

短链系统用于为长链接创建较短的别名，这些别名叫做短链接。当用户点击短链接时，他们会被**重定向到原始 URL**。

比如

```
例如我们可以通过 tinyUrl 
缩短链接 https://store.steampowered.com/app/1375870/Comrade_Trumps_Reelection/ 
为 https://tinyurl.com/yx93wn76。
```

发送短信等的时候可以减少url长度

### 302和301对区别

**301永久重定向**，即浏览器只需要第一次请求拿到长链接后，下次再去访问这个短链就不会向短网址服务器请求了，而是直接从浏览器的缓存里拿。这样可以提高浏览器的访问速度，但是也有一个问题，就是如果我们想统计活动链接的访问次数就无从下手了。或者是这个活动结束了想删除访问入口，但由于浏览器缓存可能还会导致有用户访问到。所以一般不使用301。

**302 临时重定向**，即每次访问短链都会去请求短网址服务器（除非响应中用 Cache-Control 或 Expired 暗示浏览器缓存），这样就便于 server **数据监控**，所以虽然用 302 会给 server 增加一点压力，但明显是利大于弊的。

### 基本能力和流程

1. 生成短链：根据长链 获取 短链，并记录
2. 找到长链：根据短链 映射 长链
3. 查询是否已生成：根据长链 查短链
4. 超时过期：短链 超时清理机制

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202208161810504.png" alt="fa62872b21de4f92b500a9fb98f8cd37"  />



### 生成短链

确保长链的唯一性

比如：对长链进行哈希

哈希冲突？

比如：mysql，在短链字段上，建立唯一索引，要是提高性能可以使用布隆过滤器

### 存储短链

mysql、redis

数据结构：map等

#### mysql存储映射关系

字段

| ID   | 长链 | 长链HashCode | 短链 | 短链HashCode |
| ---- | ---- | ------------ | ---- | ------------ |

根据短链获取长链 或者 根据长链获取短链：使用类似HashMap的get算法，先根据HashCode查询，然后再根据短链文本查询

分析：过期时间需要额外逻辑，并发性能低

扩展：可以用MD5代替HashCode

#### Redis代替DB存储映射关系

为了hash冲突就需要解决，一个Code对应多文本场景。

根据长链找短链场景：

1. 长链 计算Hash值
2. 根据Hash值获取value，value应该是一个列表，且需要存储长短链
3. 数据结构：

```
{
	"HashCode":[
		{唯一ID, LongUrl, ShortUrl},
		{唯一ID, LongUrl, ShortUrl}
	],
}
```

##### 1:M场景 超时机制稍微借助逻辑实现

1. 唯一ID作为key设置expire过期时间
2. 查询到“唯一ID”需要判断是否过期

优点是查询性能高，可以抗量，且自带过期机制

缺点是需要维护结构关系稍显繁琐复杂

如果能保障 URL和Hash值 1:1关系，数据结构稍微简单点，也需要维护多个kv关系

##### 长短1:1场景改进方案

前提：

1. URL和Hash值 1:1关系
2. 只对长链做Hash值，短链比较短就直接查询吧
3. 使用redis实现

分析：

1. URL根据Hash算法直接计算
2. 冲突解决：短链需要判重，如果重复则长链添加固定字符串后继续计算短链判重
3. 判重优化：可以使用布隆过滤器判断短链是否已经有了
4. hash算法可以是：MD5,SHA加密算法；非加密型MurmurHash 算法

存储kv对：

1. 长 Code 》 短
2. 短 》长

