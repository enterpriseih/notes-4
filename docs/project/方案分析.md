# 15分钟未支付取消订单

## 一、利用任务调度定时任务轮训订单表

### 方案描述

每隔n分钟，搜索订单表中**订单时间>15分钟**的记录，将订单状态改为取消。

### 实现细则

- 单体应用：利用Spring-Task或者Quartz等单机任务调度工具定时执行
- 集群环境：利用分布式任务调度工具XXL-JOB

### 优势

实现简单

### 劣势

时效性差，n分钟扫描一次，订单状态不能及时更新。

n秒钟扫描一次，订单表查询压力大。



## 二、Redis6客户端缓存监听

### 方案描述

Redis6客户端缓存监听方案，监听Redis6数据变化

### 实现细则

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207151115249.png" alt="iShot_2022-07-15_11.12.44" style="zoom:50%;" />

除了在数据库中写数据，还需要将当前未支付订单的编号放入redis的set集合中

再单独创建kv，key -> 订单编号，value -> 创建订单的实例，900s。

取消订单的时候通过查找，由实例进行取消。

发现超时后，会**主动推送给产生订单的实例**

- 实现

修改redis的redis.conf文件

找到 notify-keyspace-events Ex 这一行 取消行前边的注释 开启键空间失效通知

新建Listener

```java
@Component
@Slf4j
public class RedisKeyExpirationListener extends KeyExpirationEventMessageListener {

    @Autowired
    private OrderService orderService;

    public RedisKeyExpirationListener(RedisMessageListenerContainer listenerContainer) {
        super(listenerContainer);
    }

    @Override
    public void onMessage(Message message, byte[] pattern) {
        // 用户做自己的业务处理即可,注意message.toString()可以获取失效的key
        String expiredKey = message.toString();
        log.info("------------------redis key 失效; key = " + expiredKey);
        if (expiredKey.startsWith(GlobalConstant.RedisPrefixKey.ORDER_PREFIX)) {
            // 获取订单orderNO
            String orderNo = expiredKey.substring(expiredKey.lastIndexOf(":")+1);
            // 将待支付的订单改为已取消(超时未支付)
            orderService.orderPaidTimeout(orderNo);
        }
    }
}
```

新建配置类

```java
@Configuration
public class RedisListenerConfig {

    @Bean
    RedisMessageListenerContainer container(RedisConnectionFactory connectionFactory) {
        RedisMessageListenerContainer container = new RedisMessageListenerContainer();
        container.setConnectionFactory(connectionFactory);
        return container;
    }

}
```

### 优势

及时有效，具备主动推送功能

集群友好，哪个实例发起的订单哪个实例负责取消

### 劣势

基于长链接，连接重启后客户端缓存监听机制会失效，需要手动补偿

实例数量发生变化，需要重新分配



## 三、MQ的延迟队列、死信队列

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207151156759.png" alt="iShot_2022-07-15_11.55.10" style="zoom:50%;" />

[实现参考](https://blog.csdn.net/isWeisen/article/details/103615519?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-103615519-blog-112166491.pc_relevant_multi_platform_whitelistv3&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-103615519-blog-112166491.pc_relevant_multi_platform_whitelistv3&utm_relevant_index=1)





# 秒杀系统

https://blog.csdn.net/zero__007/article/details/108890053



# 短链系统

https://blog.csdn.net/weixin_42754896/article/details/126024740

短链系统用于为长链接创建较短的别名，这些别名叫做短链接。当用户点击短链接时，他们会被**重定向到原始 URL**。

比如

```
例如我们可以通过 tinyUrl 
缩短链接 https://store.steampowered.com/app/1375870/Comrade_Trumps_Reelection/ 
为 https://tinyurl.com/yx93wn76。
```

发送短信等的时候可以减少url长度

### 302和301对区别

**301永久重定向**，即浏览器只需要第一次请求拿到长链接后，下次再去访问这个短链就不会向短网址服务器请求了，而是直接从浏览器的缓存里拿。这样可以提高浏览器的访问速度，但是也有一个问题，就是如果我们想统计活动链接的访问次数就无从下手了。或者是这个活动结束了想删除访问入口，但由于浏览器缓存可能还会导致有用户访问到。所以一般不使用301。

**302 临时重定向**，即每次访问短链都会去请求短网址服务器（除非响应中用 Cache-Control 或 Expired 暗示浏览器缓存），这样就便于 server **数据监控**，所以虽然用 302 会给 server 增加一点压力，但明显是利大于弊的。

### 基本能力和流程

1. 生成短链：根据长链 获取 短链，并记录
2. 找到长链：根据短链 映射 长链
3. 查询是否已生成：根据长链 查短链
4. 超时过期：短链 超时清理机制

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202208161810504.png" alt="fa62872b21de4f92b500a9fb98f8cd37"  />



### 生成短链

确保长链的唯一性

比如：对长链进行哈希

哈希冲突？

比如：mysql，在短链字段上，建立唯一索引，要是提高性能可以使用布隆过滤器

### 存储短链

mysql、redis

数据结构：map等

#### mysql存储映射关系

字段

| ID   | 长链 | 长链HashCode | 短链 | 短链HashCode |
| ---- | ---- | ------------ | ---- | ------------ |

根据短链获取长链 或者 根据长链获取短链：使用类似HashMap的get算法，先根据HashCode查询，然后再根据短链文本查询

分析：过期时间需要额外逻辑，并发性能低

扩展：可以用MD5代替HashCode

#### Redis代替DB存储映射关系

为了hash冲突就需要解决，一个Code对应多文本场景。

根据长链找短链场景：

1. 长链 计算Hash值
2. 根据Hash值获取value，value应该是一个列表，且需要存储长短链
3. 数据结构：

```
{
	"HashCode":[
		{唯一ID, LongUrl, ShortUrl},
		{唯一ID, LongUrl, ShortUrl}
	],
}
```

##### 1:M场景 超时机制稍微借助逻辑实现

1. 唯一ID作为key设置expire过期时间
2. 查询到“唯一ID”需要判断是否过期

优点是查询性能高，可以抗量，且自带过期机制

缺点是需要维护结构关系稍显繁琐复杂

如果能保障 URL和Hash值 1:1关系，数据结构稍微简单点，也需要维护多个kv关系

##### 长短1:1场景改进方案

前提：

1. URL和Hash值 1:1关系
2. 只对长链做Hash值，短链比较短就直接查询吧
3. 使用redis实现

分析：

1. URL根据Hash算法直接计算
2. 冲突解决：短链需要判重，如果重复则长链添加固定字符串后继续计算短链判重
3. 判重优化：可以使用布隆过滤器判断短链是否已经有了
4. hash算法可以是：MD5,SHA加密算法；非加密型MurmurHash 算法

存储kv对：

1. 长 Code 》 短
2. 短 》长
