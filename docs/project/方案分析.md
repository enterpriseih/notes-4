# 100万行的表实时反馈有错误的行

多线程，线程池，分区间进行遍历



# 一亿个数中找前100

#### 1、快排

时间复杂度nlogn，空间：一个数字按照4个字节（1Byte字节 = 8bits），最多占用400m

#### 2、堆排序

最小堆，建堆的时间复杂度（mlogm），总时间复杂度nmlogm，空间复杂度100万（即m）

#### 3、分治

1亿个数分成100份，每份100万，分别找前100，再合在一起一万个数找前100



# 8G的int型数据，计算机的内存只有2G，怎么对它进行排序？（外部排序）

https://blog.csdn.net/weixin_44978620/article/details/120058061

可以使用外部排序来对它进行处理。

首先将整个文件分成许多份，比如说m份，划分的依据就是使得每一份的大小都能放到内存里。然后我们用快速排序或者堆排序等方法对每一份数据进行一个内部排序，变成有序子串。接着对这m份有序子串进行**m路归并排序**。

取这m份数据的最小元素，进行排序，输出排序后最小的元素到磁盘中，同时从该元素所在子串中读入一个元素，直到所有数据都被输出到结果中为止。

注意: 读取的时候是每次读取m个int数，通过比较之后再输出。



## [CPU飙升怎么排查](https://blog.csdn.net/m0_37542440/article/details/123679011)

1. top
	查看所有进程占系统cpu的排序，极大可能排第一的就是自己的java进程，pid就是进程号。

	或ps -ef|grep java

2. `top -Hp <pid>`

	查看Java进程下的所有线程占用cpu的情况，找到高负荷线程号

3. 将高负荷线程号转换为16进制，`printf "%x\n" <pid>`

	后续查看线程堆栈信息展示的都是十六进制，为了找到咱们的线程堆栈信息，需要把线程号转为16进制。

4. 使用jstack查询线程堆栈信息

	`jstack <pid> | grep -a 线程id（十六进制）`



### 原因分析

1. 内存消耗过多，导致Full GC次数过多；是否内存溢出，查看哪些对象使用较多
2. 是否线程数过多，导致CPU过高
3. 线程阻塞，死锁
4. 大量递归



### 补充

**Java高CPU占用排查步骤**

- top：找到占用CPU高的进程PID
- jstack PID >> java_stack.log：导出CPU占用高进程的线程栈
- top -Hp PID：找出PID的进程占用CPU过高的线程tid。（或使用命令 ps -mp PID -o THREAD,tid,time | sort -rn | less）
- printf “%x\n” tid：将需要的线程ID转换为16进制格式。
- less java_stack.log：查找转换成为16进制的线程TID，找到对应的线程栈，分析并处理问题。

**Java高内存占用排查步骤**

- top：找到占用内存(RES列)高的Java进程PID。
- jmap -heap PID：查看heap内存使用情况。
- jps -lv ：查看JVM参数配置。
- jstat -gc PID 1000：收集每秒堆的各个区域具体占用大小的gc信息。
- jmap -dump:live,format=b,file=heap_dump.hprof PID ：导出堆文件。
- 使用MAT打开堆文件，分析问题。

**Java堆外内存泄漏排查步骤**

- top：找到占用内存(RES列)较高的Java进程PID。
- jstat -gcutil PID 1000 查看每秒各个区域占堆百分比，若gc正常，则分析堆外内存使用情况。
- jcmd PID VM.native_memory detail，该命令需要添加JVM参数 -XX:NativeMemoryTracking=detail，并重启Java进程才能生效，该命令会显示内存使用情况，查看输出结果，总的committed的内存是否小于物理内存（RES），因为jcmd命令显示的内存包含堆内内存、Code区域、通过unsafe.allocateMemory和DirectByteBuffer申请的内存，但是不包含其他Native Code（C代码）申请的堆外内存。
- pmap -x PID | sort -rn -k 3：查看内存分布，是否有地址空间不在jcmd命令所给出的地址空间中。
- 用工具定位堆外内存，如gperftools、gdb、strace等。



# 15分钟未支付取消订单

## 一、利用任务调度定时任务轮训订单表

### 方案描述

每隔n分钟，搜索订单表中**订单时间>15分钟**的记录，将订单状态改为取消。

### 实现细则

- 单体应用：利用Spring-Task或者Quartz等单机任务调度工具定时执行
- 集群环境：利用分布式任务调度工具XXL-JOB

### 优势

实现简单

### 劣势

时效性差，n分钟扫描一次，订单状态不能及时更新。

n秒钟扫描一次，订单表查询压力大。



## 二、Redis6客户端缓存监听

### 方案描述

Redis6客户端缓存监听方案，监听Redis6数据变化

### 实现细则

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207151115249.png" alt="iShot_2022-07-15_11.12.44" style="zoom:50%;" />

除了在数据库中写数据，还需要将当前未支付订单的编号放入redis的set集合中

再单独创建kv，key -> 订单编号，value -> 创建订单的实例，900s。

取消订单的时候通过查找，由实例进行取消。

发现超时后，会**主动推送给产生订单的实例**

- 实现

修改redis的redis.conf文件

找到 notify-keyspace-events Ex 这一行 取消行前边的注释 开启键空间失效通知

新建Listener

```java
@Component
@Slf4j
public class RedisKeyExpirationListener extends KeyExpirationEventMessageListener {

    @Autowired
    private OrderService orderService;

    public RedisKeyExpirationListener(RedisMessageListenerContainer listenerContainer) {
        super(listenerContainer);
    }

    @Override
    public void onMessage(Message message, byte[] pattern) {
        // 用户做自己的业务处理即可,注意message.toString()可以获取失效的key
        String expiredKey = message.toString();
        log.info("------------------redis key 失效; key = " + expiredKey);
        if (expiredKey.startsWith(GlobalConstant.RedisPrefixKey.ORDER_PREFIX)) {
            // 获取订单orderNO
            String orderNo = expiredKey.substring(expiredKey.lastIndexOf(":")+1);
            // 将待支付的订单改为已取消(超时未支付)
            orderService.orderPaidTimeout(orderNo);
        }
    }
}
```

新建配置类

```java
@Configuration
public class RedisListenerConfig {

    @Bean
    RedisMessageListenerContainer container(RedisConnectionFactory connectionFactory) {
        RedisMessageListenerContainer container = new RedisMessageListenerContainer();
        container.setConnectionFactory(connectionFactory);
        return container;
    }

}
```

### 优势

及时有效，具备主动推送功能

集群友好，哪个实例发起的订单哪个实例负责取消

### 劣势

基于长链接，连接重启后客户端缓存监听机制会失效，需要手动补偿

实例数量发生变化，需要重新分配



## 三、MQ的延迟队列、死信队列

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207151156759.png" alt="iShot_2022-07-15_11.55.10" style="zoom:50%;" />

[实现参考](https://blog.csdn.net/isWeisen/article/details/103615519?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-103615519-blog-112166491.pc_relevant_multi_platform_whitelistv3&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-103615519-blog-112166491.pc_relevant_multi_platform_whitelistv3&utm_relevant_index=1)

下单之后，将取消订单的消息交给消息队列。

如果时间到了之后，去查看该订单是否已经支付，如果未支付，就取消掉，就是将这个过程交给消息队列去完成。



