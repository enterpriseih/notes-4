# 分布式系统的CAP原理

### CAP原理

- Consistency (一致性)

- Availability (可用性)

- Partition tolerance (分区容错性)

> 由于硬件条件，一个分布式系统必须保证分区容错性，要么CP要么AP，无法同时保证。

**一致性**(C)：一个分布式系统中各个节点之间能**及时的同步数据**，在数据同步过程中，是不能对外提供服务的

**可用性**(A)：负载过大后，集群整体是否还能响应客户端的读写请求。(服务对外要保证可用，而且是**正常响应时间**)

**分区容错性**(P)：分区容错性，就是高可用性，一个节点崩了，并不影响其它的节点(100个节点，挂了几个，不影响服务，越多机器越好)

### 不能同时满足的原因

#### CA 满足的情况下，P不能满足

数据同步(C)需要时间，也要正常的时间内响应(A)，那么机器数量就要少，所以P就不满足

#### CP 满足的情况下，A不能满足

数据同步(C)需要时间, 机器数量也多(P)，但是同步数据需要时间，所以不能再正常时间内响应，所以A就不满足

#### AP 满足的情况下，C不能满足

机器数量也多(P)，正常的时间内响应(A)，那么数据就不能及时同步到其他节点，所以C不满足

### 注册中心选择的原则

Zookeeper：CP设计，保证了一致性，集群搭建的时候，某个节点失效，则会进行选举行的leader，或者半数以上节点不可用，则无法提供服务，因此可用性没法满足。

Eureka：AP原则，无主从节点，一个节点挂了，自动切换其他节点可以使用，去中心化

分布式系统中P肯定要满足，所以我们只能在一致性和可用性之间进行权衡 

- 如果要求一致性，则选择zookeeper，如金融行业 

- 如果要求可用性，则Eureka，如教育、电商系统 

没有最好的选择，最好的选择是根据业务场景来进行架构设计

# BASE理论

由于不能同时满⾜CAP，所以出现了BASE理论： 

1. BA：Basically Available，表示基本可⽤，表示可以允许⼀定程度的不可⽤，⽐如由于系统故障， 请求时间变⻓，或者由于系统故障导致部分⾮核⼼功能不可⽤，都是允许的 
2. S：Soft state：表示分布式系统可以处于⼀种中间状态，⽐如数据正在同步 
3. E：Eventually consistent，表示最终⼀致性，不要求分布式系统数据实时达到⼀致，允许在经过⼀ 段时间后再达到⼀致，在达到⼀致过程中，系统也是可⽤的

# 数据一致性模型

- **强一致性**：当更新操作完成之后，任何多个后续进程的访问都会返回最新的更新过的值，这种是对用户最友好的，就是用户上一次写什么，下一次就保证能读到什么。根据 CAP理论，这种实现需要牺牲可用性。
- **弱一致性**：系统在数据写入成功之后，不承诺立即可以读到最新写入的值，也不会具体的承诺多久之后 可以读到。用户读到某一操作对系统数据的更新需要一段时间，称这段时间为“不一致性窗口”。
- **最终一致性**：最终一致性是弱一致性的特例，强调的是所有的数据副本，在经过一段时问的同步之后。最终都能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。到达最终一致性的时间，就是不一致窗口时间；在没有故障发生的前提下，不一致窗口的时问主要受通信延迟，系统负载和复制副本的个数影响。最终一致性模型根据其提供的不同保证可以划分为更多的模型，包括因果一致性和会话一致性。

# 什么是RPC

RPC (Remote Procedure Call)，表示**远程过程调⽤**，一种进程间的通信**方式**，允许**像调用本地服务一样调用远程服务**。

> RPC包括通信协议和序列化协议
>
> 通信协议：http、tcp
>
> 序列化协议：protobuf、thrift

### RPC和Http的区别

先有rpc，后有http

rpc是一种方式，http是一种协议

1、灵活性

RPC，要求服务器和客户端都采用相同的框架，相同语言

- 目前不需要统一技术栈了，只需要对接好参数就可以了

HTTP，跨语言、跨平台，更加灵活

2、传输协议

RPC，可以基于TCP协议，也可以基于HTTP、UDP等协议

- 使用tcp的时候可以减少很多请求头报文

HTTP，基于HTTP协议

3、性能消耗，主要在于序列化和反序列化的耗时

RPC，可以基于thrift实现高效的二进制传输

- Thrift是一种接口描述语言和二进制通讯协议，它被用来定义和创建跨语言的服务。

HTTP，大部分是通过json来实现的，字节大小和序列化耗时都比thrift要更消耗性能

4、网络开销

RPC，**长连接**，不必每次通信都要像http一样去3次握手什么的，减少了网络开销

HTTP，**短连接**

## 为什么有HTTP还要有RPC

[参考](https://mp.weixin.qq.com/s/_pPY58hDvSNqL62-ZGBG9g)


# 什么是RMI

RMI (Remote Method Invocation) 模型是一种分布式对象应用，使用 RMI 技术可以使一个 JVM 中的对象，调用另一个 JVM 中的对象方法并获取调用结果。

可以理解为是java中用于实现RPC的一种机制，跨JVM调用对象

直接或间接实现接口 java.rmi.Remote 成为存在于服务器端的远程对象，供客户端访问并提供一定的服务。

远程对象必须实现java.rmi.server.UniCastRemoteObject类，这样才能保证客户端访问获得远程对象时，该远程对象将会把自身的一个拷贝以Socket的形式传输给客户端，此时客户端所获得的这个拷贝称为“存根”，而服务器端本身已存在的远程对象则称之为“骨架”。其实此时的存根是客户端的一个代理，用于与服务器端的通信，而骨架也可认为是服务器端的一个代理，用于接收客户端的请求之后调用远程方法来响应客户端的请求

---



# 分布式ID

单体架构中可以使用数据库的主键，或者直接在内存中维护一个自增数字来作为ID都是可以的，但对于一个分布式系统，就可能会出现ID冲突。

1. UUID：复杂度最低，但是会影响存储空间和性能（因为无序）
2. 单机数据库的自增主键
3. redis、zookeeper的特性生成id，比如redis的自增命令、zookeeper的顺序节点

2. 雪花算法：趋势递增，因为不同机器时间可能不一致

# 分布式锁

单体架构中，多个线程属于同一个进程的，可以使用sychronized、ReentrantLock来作为锁。

但是分布式中需要一个分布式锁的生成器。

1. **zookeeper** ：利用的是zookeeper的临时节点、顺序节点、watch机制来实现的，zookeeper分布式锁的特点是高一致性，因为zookeeper保证的是**CP**，所以由它实现的分布式锁**更可靠**，不会出现混乱
2. **redis**：利用redis的setnx、lua脚本、消费订阅等机制来实现的，redis分布式锁的特点是**高可用**，因为redis保证的是**AP**，所以由它实现的分布式锁可能不可靠，不稳定（一旦redis中的数据出现了不一致），可能会出现多个客户端同时加到锁的情况

# 分布式事务：一致性算法

在分布式系统中，一次业务处理可能需要多个应用来实现，比如用户发送一次下单请求，就涉及到订单系统创建订单、库存系统减库存，而对于一次下单，订单创建与减库存应该是要同时成功或同时失败的，但在分布式系统中，如果不做处理，就很有可能出现订单创建成功，但是减库存失败，那么解决这类问题，就需要用到分布式事务。常用解决方案有：

## 2PC

2PC（Two-phase commit protocol），二阶段提交。

分为准备阶段和提交阶段。

- **准备阶段**：把除了提交事务之外的啥事都做了。

- **提交阶段**：**同步**等待所有资源的响应之后，就开始提交

（注意提交阶段不一定是提交事务，也可能是回滚事务）

假如在第一阶段所有参与者都返回准备成功，那么协调者则向所有参与者发送提交事务命令，然后等待所有事务都提交成功之后，返回事务执行成功。如果有一个失败，则都回滚。

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207252203326.jpeg" alt="v2-880b5e0866906160b663827f961d8360_720w" style="zoom: 67%;" />

若提交阶段失败：不断的重试，直到提交成功，到最后真的不行只能人工介入处理。

2PC是个**同步阻塞**协议。

**数据不一致问题**，比如当第二阶段，协调者只发送了一部分的 `commit` 请求就挂了，那么也就意味着，收到消息的数据库会进行事务的提交，而后面没收到的则不会进行事务提交，那么这时候就会产生数据不一致性问题。

## 3PC

3PC 包含了三个阶段，分别是**准备阶段**、**预提交阶段**和**提交阶段**。

`CanCommit`、`PreCommit `、` DoCommit`

- 准备阶段：询问此时的参与者是否有条件接这个事务，因此**不会一来就干活直接锁资源**，使得在某些资源不可用的情况下所有参与者都阻塞着。

- 预提交阶段：和2pc的准备阶段一样。

- 提交阶段：和2pc的提交阶段一样。

同时引入了**超时机制**。

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202208211947485.png" alt="3PC流程" style="zoom:67%;" />

> **如果是等待提交命令超时，那么参与者就会提交事务了**，因为都到了这一阶段了大概率是提交的，**如果是等待预提交命令超时，那该干啥就干啥了，反正本来啥也没干**。
>
> 然而超时机制也会带来数据不一致的问题，比如在等待提交命令时候超时了，参与者默认执行的是提交事务操作，但是**有可能执行的是回滚操作，这样一来数据就不一致了**。



## TCC

**2PC 和 3PC 都是数据库层面的，而 TCC 是业务层面的分布式事务**，就像我前面说的分布式事务不仅仅包括数据库的操作，还包括发送短信等，这时候 TCC 就派上用场了！

TCC 指的是`Try - Confirm - Cancel`。

- Try 指的是预留，即资源的预留和锁定，**注意是预留**。
- Confirm 指的是确认操作，这一步其实就是真正的执行了。
- Cancel 指的是撤销操作，可以理解为把预留阶段的动作撤销了

例如：A给B转100

1. Try：A检查账户有效性然后预留100，B只检查账户有效性的
2. Confirm：A不操作，B账户+100
3. Cancel：A释放扣除的100，B不操作

> 预留资源，不会涉及资源的争抢。



## 本地消息表（异步确保）***

思想：本地消息表其实就是利用了 **各系统本地的事务** 来实现分布式事务。

本地消息表顾名思义就是会有一张存放本地消息的表，一般都是放在数据库中，然后在执行业务的时候 **将业务的执行和将消息放入消息表中的操作放在同一个事务中**，这样就能保证**消息放入本地表中业务肯定是执行成功的**。

然后再去调用下一个操作，如果下一个操作调用成功，消息表的消息状态可以直接改成已成功。

如果调用失败，会有 **后台任务定时去读取本地消息表**，筛选出还未成功的消息再调用对应的服务，服务更新成功了再变更消息的状态。

这时候有可能消息对应的操作不成功，因此也需要重试，重试就得保证对应服务的方法是幂等的，而且一般重试会有最大次数，超过最大次数可以记录下报警让人工处理。

本地消息表其实实现的是**最终一致性**，容忍了数据暂时不一致的情况。

例如：

- 创建订单时，将“**把减少库存的消息存入数据库的操作**”和“**创建订单的操作**”加入同一个事务。
- 调用库存系统，调用成功就修改本地消息表状态为成功，否则用定时任务从本地消息表中取出未成功的消息，重试。



## 事务消息***

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207252140022.png" alt="2fef761eda144212b4e62df46bc453ef" style="zoom:80%;" />

> 事务消息又称half消息，half是指这个消息对消费者来说是不可见的。

目前**RocketMQ中支持事务消息**，它的工作原理是：

- 生产者订单系统先发送一条half消息到Broker；发送成功后再执行本地事务（创建订单）。
- 根据本地事务的结果，向Broker发送commit或rolback。
- 并且生产者订单系统还可以提供Broker**回调接口**，当Broker发现一段时间half消息没有收到任何操作命令，则会主动调此接口产看生产者事务是否执行成功（查询订单是否创建成功）
- 一旦half消息commit了，消费者库存系统就会来消费，如果消费成功，则消息销毁，分布式事务成功结束。
- 如果消费失败，则根据重试策略进行重试，最后还失败则进入死信队列，等待进一步处理。

> RocketMQ提供了事务消息的功能，只需要定义**事务回调接口**就好。

## 不使用分布式事务，怎么实现一致性？

比如mq崩了，用户支付了，支付系统给mq传递消息，但是mq崩了，但订单状态还是待支付。

设置一个定时任务，15分钟之后，根据订单id去支付系统那边查询是否支付成功，如果支付成功，就更新订单状态为已支付。

# 分布式架构下，session共享方案

### 1、存入cookie（有风险）

### 2、服务器之间进行session同步

不过当服务器数量较多的时候，同步会有延迟甚至失败

### 3、使用redis存储

- 实现了session共享
- 可以水平扩展（增加redis服务器）
- 服务器重启，session不会丢失
- 可以跨平台（网页端和app端）

# 服务注册与发现

服务注册与发现是分为注册和发现两个关键的步骤。

**服务注册**：服务进程在注册中心注册自己的元数据信息。通常包括主机和端口号，有时还有身份验证信息，协议，版本号，以及运行环境的信息。

**服务发现**：客户端服务进程向注册中心发起查询，来获取服务的信息。服务发现的一个重要作用就是提供给客户端一个可用的服务列表。

## 服务注册

服务注册有两种形式：客户端注册和代理注册。

**客户端注册**

客户端注册是服务自己要负责注册与注销的工作。当服务启动后注册线程向注册中心注册，当服务下线时注销自己。

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202208031003344.png" alt="20210504232139-2021-05-04-23-21-40" style="zoom: 50%;" >

这种方式的缺点是注册注销逻辑与服务的业务逻辑耦合在一起，如果服务使用不同语言开发，那需要适配多套服务注册逻辑。

**代理注册**

代理注册由一个单独的代理服务负责注册与注销。当服务提供者启动后以某种方式通知代理服务，然后代理服务负责向注册中心发起注册工作。

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202208031003560.png" alt="20210504232151-2021-05-04-23-21-52" style="zoom: 50%;" >


这种方式的缺点是多引用了一个代理服务，并且代理服务要保持高可用状态。

## 服务发现

服务发现也分为客户端发现和代理发现。

**客户端发现**

客户端发现是指客户端负责向注册中心查询可用服务地址，获取到所有的可用实例地址列表后客户端根据负载均衡算法选择一个实例发起请求调用。

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202208031004780.png" alt="20210504232203-2021-05-04-23-22-04" style="zoom: 50%;" >

这种方式非常直接，客户端可以控制负载均衡算法。但是缺点也很明显，获取实例地址、负载均衡等逻辑与服务的业务逻辑耦合在一起，如果服务发现或者负载平衡有变化，那么所有的服务都要修改重新上线。

**代理发现**

代理发现是指新增一个路由服务负责服务发现获取可用的实例列表，服务消费者如果需要调用服务A的一个实例可以直接将请求发往路由服务，路由服务根据配置好的负载均衡算法从可用的实例列表中选择一个实例将请求转发过去即可，如果发现实例不可用，路由服务还可以自行重试，服务消费者完全不用感知。

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202208031004665.png" alt="20210504232217-2021-05-04-23-22-17" style="zoom: 50%;" >


## 心跳机制

如果服务有多个实例，其中一个实例出现宕机，注册中心是可以实时感知到，并且将该实例信息从列表中移出，也称为摘机。

如何实现摘机？业界比较常用的方式是通过心跳检测的方式实现，心跳检测有**主动**和**被动**两种方式。

**被动检测**是指服务主动向注册中心发送心跳消息，时间间隔可自定义，比如配置5秒发送一次，注册中心如果在三个周期内比如说15秒内没有收到实例的心跳消息，就会将该实例从列表中移除。

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202208031004246.png" alt="20210504232235-2021-05-04-23-22-35" style="zoom: 50%;" >

上图中服务A的实例2已经宕机不能主动给注册中心发送心跳消息，15秒之后注册就会将实例2移除掉。

**主动检测**是注册中心主动发起，每隔几秒中会给所有列表中的服务实例发送心跳检测消息，如果多个周期内未发送成功或未收到回复就会主动移除该实例。

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202208031004001.png" alt="20210504232247-2021-05-04-23-22-48" style="zoom: 50%;" >

# [Zookeeper](./zookeeper/Zookeeper.md)

分布式应用程序协调软件

## ZAB协议

ZAB协议是Zo0keeper用来实现一致性的原子广播协议，该协议描述了Zookeeper是如何实现一致性的，分为三个阶段：
1. 领导者选举阶段：从Zookeeper集群中选出一个节点作为Leader，所有的写请求都会由Leader节点来处理
2. 数据同步阶段：集群中所有节点中的数据要和Leader节点保持一致，如果不一致则要进行同步
3. 请求广播阶段：当Leader节点接收到写请求时，会利用两阶段提交来广播该写请求，使得写请求像事务一样在其他节点上执行，达到节点上的数据实时一致但值得注意的是，Zookeeper只是尽量的在达到强一致性，实际上仍然只是最终一致性的。

# 负载均衡算法

### 1、轮询法

将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。

### 2、随机法

通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。由概率统计理论可以得知，随着客户端调用服务端的次数增多，其实际效果越来越接近于平均分配调用量到后端的每一台服务器，也就是轮询的结果。

### 3、源地址哈希法

源地址哈希的思想是根据获取客户端的IP地址，通过**哈希函数**计算得到的一个数值用该数值对服务器列表的大小进行取模运算，得到的结果便是客服端要**访问服务器的序号**。采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问。

### 4、加权轮询法

不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，让其处理更多的请求；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。

### 5、加权随机法

与加权轮询法一样，加权随机法也根据后端机器的配置，系统的负载分配不同的权重。不同的是，它是按照权重随机请求后端服务器，而非顺序。

### 6、最小连接数法

最小连接数算法比较灵活和智能，由于后端服务器的配置不尽相同，对于请求的处理有快有慢，它是根据后端服务器当前的连接情况，动态地选取其中当前积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器。

# 服务雪崩？服务限流？

## 一、服务雪崩

当服务A调用服务B，服务B调用C，此时大量请求突然请求服务A，假如服务A本身能抗住这些请求，但是如果服务C抗不住，导致服务C请求堆积，从而服务B请求堆积，从而服务A不可用，这就是服务雪崩，解决方式就是服务降级和服务熔断。

C顶不住，导致B堆积，从而A不可用了。

## 二、服务限流

服务限流是指在高并发请求下，为了保护系统，可以**对访问服务的请求进行数量上的限制**，从而防止系统不被大量请求压垮，在秒杀中，限流是非常重要的。

[限流算法](./限流算法.md)：

1. 计数限流
2. 固定窗口限流
3. 滑动窗口限流
4. 漏桶算法
5. 令牌桶算法

# 服务熔断？服务降级？

## 一、服务熔断

当服务A调用的某个**服务B不可用时**，上游服务A为了保证自己不受影响，从而**不再调用服务B**，直接返回一个结果，减轻服务A和服务B的压力，直到服务B恢复。

## 二、服务降级

当发现系统压力过载时，可以通过关闭某个服务，或限流某个服务来**减轻系统压力**。服务水平下降。

## 三、异同

**同**：

1. 都是为了防止系统崩溃
2. 都让用户体验到某些功能暂时不可用

**异**：熔断是下游服务故障触发的，降级是为了降低系统负载。

# SOA和微服务

SOA（Service-Oriented Architecture，面向服务架构）和微服务都是分布式架构。

SOA：所有服务都注册在总线上，当调用服务时，从总线上查找服务信息，然后调用。

微服务：将系统中的各个功能抽成一个个小的应用程序，基本保持一个应用对应的一个服务的架构。

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207132223010.png" alt="aHR0cHM6Ly9waWMyLnpoaW1nLmNvbS84MC92Mi1iZGE0YWVlMDg1OTUwNjczN2ZmNGNmOWIxM2ZkN2UxY183MjB3LmpwZw"  />

