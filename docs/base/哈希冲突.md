### 哈希冲突

#### 1、链地址法

对于相同的哈希值，使用链表进行连接。HashMap

**优点**：处理简单，容易删除，只需要简单地删去链表上相应的结点即可；

**缺点**：一旦哈希冲突多了，哈希表会退化成链表，查询效率会从O(1)变为O(n)。JDK8的HashMap针对这种情况有做优化，冲突超过8个会将链表转换为**红黑树**，提高查询效率。

#### 2、再哈希法

提供多个函数，如果第一个哈希函数计算出来的key的哈希值冲突了，则使用第二个哈希函数计算key的哈希值。

**优点**：减少哈希冲突次数

**缺点**：这种方式会增加哈希计算的开销，影响读写的效率。

#### 3、建立公共溢出区

将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。

查找时，先从哈希表查，查不到再去公共溢出区查。

**缺点**：哈希冲突多了，公共溢出区会膨胀的非常厉害，查询的效率也有影响。

#### 4、开放定址法

`Hi=（H（key）+di）% m（i=1，2，…，n）`

该方法一次探测下一个地址，直到有空的地址后插入，若整个空间都找不到空余的地址，则产生溢出。**ThreadLocalMap**

> 一是Threadlocal对象不多，对象不多的话使用开放寻址法效率也不低（线性遍历）。
>
> 二是Threadlocal不多的话，哈希冲突的概率也不高，使用开放寻址实现更简单。
>
> 三是开放寻址不用像hash Map 那样考虑加载因子（取舍内存和哈希冲突）。

**优点**：只要哈希表还有位置，通过不断的探测，总能找到合适的位置。

**缺点**：

1. 是探测的次数不可控，一旦探测次数骤增，会严重影响哈希表的读写性能；

2. 删除比较麻烦；

##### > 具体分类

1、线性探测再散列

**顺序查看下一个单元**，直到找出一个空单元或查遍全表；`di=1，2，3，…，m-1`

2、二次平方探测再散列

在表的**左右进行跳跃式探测**，直到找出一个空单元或查遍全表

```
di=1^2，-1^2，2^2，-2^2，…，k^2，-k^2 ( k<=m/2 )
```

3、伪随机探测再散列

建立一个伪随机数发生器，并给一个随机数作为起点

di=伪随机数序列。具体实现时，应建立一个伪随机数发生器，（如i=(i+p) % m），并给定一个随机数做起点。

```
例如，已知哈希表长度m=11，
哈希函数为：H（key）= key % 11，则H（47）=3，H（26）=4，H（60）=5，
假设下一个关键字为69，则H（69）=3，与47冲突。

如果用线性探测再散列处理冲突，
下一个哈希地址为H1=（3 + 1）% 11 = 4，
仍然冲突，再找下一个哈希地址为H2=（3 + 2）% 11 = 5，
还是冲突，继续找下一个哈希地址为H3=（3 + 3）% 11 = 6，
此时不再冲突，将69填入5号单元。

如果用二次探测再散列处理冲突，
下一个哈希地址为H1=（3 + 12）% 11 = 4，
仍然冲突，再找下一个哈希地址为H2=（3 - 12）% 11 = 2，
此时不再冲突，将69填入2号单元。

如果用伪随机探测再散列处理冲突，
且伪随机数序列为：2，5，9，………，
则下一个哈希地址为H1=（3 + 2）% 11 = 5，
仍然冲突，再找下一个哈希地址为H2=（3 + 5）% 11 = 8，
此时不再冲突，将69填入8号单元。

```

