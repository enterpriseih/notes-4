项目名称：名医汇预约挂号平台

b2c：前台用户和后台管理

**开发环境**：IDEA+JDK1.8+ MySQL5.7

**技术选型**：Sping+SpringBoot+SpringCloud+mysql+MybatisPlus+Redis+MongoDB +RabbitMQ+Vue+elementUI

**项目描述**：名医汇预约挂号平台是近年来开展的一项便民就医服务，旨在缓解看病难、挂号难的就医难题，让患者能够随时随地轻松挂号！采用SpringCloud微服务架构和前后端分离技术，后台管理系统分为医院设置，数据字典，用户管理，订单管理，统计管理5个模块，前台用户系统分为：医院详情，用户登录，就诊人管理，预约挂号，就医提醒模块。

**责任描述**：

1. 参与后台需求分析，功能实现的讨论； 
2. 医院设置模块，医院设置与医院列表的增删改查。 
3. 数据字典模块，对数据字典树形显示，excel导入，导出接口开发。 
4. 前台用户登录功能，手机验证码，微信扫描登录接口开发。 
5. 前台用户实名认证与就诊人管理的增删改查。 
6. 订单管理模块订单列表，详情的查看。 

**技术描述**：

1. 基于MyBatisPlus实现数据的增删改查； 
2. 通过redis配置类与Cacheable注解实现数据字典中数据的缓存,提高查询效率; 
3. 通过EasyExcel实现数据字典的导入导出； 
4. 基于SpringCloud中Feign组件实现远程调用，gateway配置网关； 
5. 基于MongDB实现在医院基本信息，科室信息，排班信息的存储，结合Springboot对数据进行查看功能的编码; 
6. 主要第三方API：阿里云短信，微信授权，阿里云OSS云存储; 
7. 使用swagger2进行接口测试。



---



# 模块架构初步

hospital-manage：医院接口模拟端（已开发，直接使用）

yygh-parent：根目录，管理子模块：

- common：公共模块父节点
	- common-util：工具类模块，所有模块都可以依赖于它
	- rabbit-util：rabbitmq业务封装
	- service-util：service服务的工具包，包含service服务的公共配置类，所有               service模块依赖于它

- server-gateway：服务网关

- model：实体类模块

- service：api接口服务父节点
	- service-hosp：医院api接口服务
	- service-cmn：公共api接口服务
	- service-user：用户api接口服务
	- service-order：订单api接口服务
	- service-oss：文件api接口服务
	- service-sms：短信 api接口服务
	- service-task：定时任务服务
	- service-statistics：统计api接口服务
	- service-client：feign服务调用父节点
	- service-cmn-client：公共api接口
	- service-hosp-client：医院api接口
	- service-order-client：订单api接口
	- service-user：用户api接口

# Swagger2

编写和维护接口文档是每个程序员的职责，根据Swagger2可以快速帮助我们编写最新的API接口文档，再也不用担心开会前仍忙于整理各种资料了，间接提升了团队开发的沟通效率。

常用注解

swagger通过注解表明该接口会生成文档，包括接口名、请求方法、参数、返回信息的等等。

@Api：修饰整个类，描述Controller的作用

@ApiOperation：描述一个类的一个方法，或者说一个接口

@ApiParam：单个参数描述

@ApiModel：用对象来接收参数

@ApiModelProperty：用对象接收参数时，描述对象的一个字段

@ApiImplicitParam：一个请求参数

@ApiImplicitParams：多个请求参数



配置在service_util中

下列地址就是api操作地址

`http://localhost:8201/swagger-ui.html`

### 缺少swagger2运行环境问题

`[Failed to start bean 'documentationPluginsBootstrapper'; nested exception is java.lang.NullPointerException]`

原因，在boot2.6.x版本中，缺少swagger2运行环境，

解决方法：

不可行1、在swagger2点配置类上加上`@EnableWebMvc`

2、配置文件中加上

```properties
spring.mvc.pathmatch.matching-strategy=ant_path_matcher
```



# 统一返回定义

在common_uitl中定义Result和ResultCodeEnum

com.yienx.yygh.common.result



# 条件查询vo

vo类封装条件值

然后编写controller

```
@RequestBody(required = false) HospitalSetQueryVo hospitalSetQueryVo
```

将表单值传到对应的对象中，false表示可以为空



# 全局异常处理

spring boot 默认情况下会映射到 /error 进行异常处理，但是提示并不十分友好，下面自定义异常处理，提供友好展示。

common-util里创建GlobalExceptionHandler

## 自定义异常

```java
try {
    int a = 1/0;
} catch (Exception e) {
    throw new YyghException("除数不能为0", 201);
}
// 
@ExceptionHandler(YyghException.class)
@ResponseBody
public Result error(YyghException e) {
    e.printStackTrace();
    // return Result.fail();
    return Result.build(e.getCode(), e.getMessage());
}
// ResponseBody
{
  "code": 201,
  "message": "除数不能为0",
  "data": null,
  "ok": false
}
```



# 日志

日志记录器（Logger）的行为是分等级的。如下表所示：

分为：OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL

从左往右显示的越全

默认情况下，spring boot从控制台打印出来的日志级别只有INFO及以上级别，可以配置日志级别

```properties
# 设置日志级别
logging.level.root=WARN
```



这种方式只能将日志打印在控制台上

## 配置日志

resources/logback-spring.xml



# 数据字典



# SpringCache + Redis 缓存数据

## 注解

#### @Cacheable

根据方法对其返回结果进行缓存，下次请求时，如果缓存存在，则直接读取缓存数据返回；如果缓存不存在，则执行方法，并把返回的结果存入缓存中。一般用在查询方法上。

| 属性/方法名 | 解释                                             |
| ----------- | ------------------------------------------------ |
| value       | 缓存名，必填，它指定了你的缓存存放在哪块命名空间 |
| cacheNames  | 与 value 差不多，二选一即可                      |
| key         | 可选属性，可以使用 SpEL 标签自定义缓存的key      |



### @CachePut

使用该注解标志的方法，每次都会执行，并将结果存入指定的缓存中。其他方法可以直接从响应的缓存中读取缓存数据，而不需要再去查询数据库。一般用在新增方法上。

内部属性同上

### @CacheEvict

使用该注解标志的方法，会清空指定的缓存。一般用在更新或者删除方法上

| 属性/方法名      | 解释                                                         |
| ---------------- | ------------------------------------------------------------ |
| value            | 缓存名，必填，它指定了你的缓存存放在哪块命名空间             |
| cacheNames       | 与 value 差不多，二选一即可                                  |
| key              | 可选属性，可以使用 SpEL 标签自定义缓存的key                  |
| allEntries       | 是否清空所有缓存，默认为  false。如果指定为 true，则方法调用后将立即清空所有的缓存 |
| beforeInvocation | 是否在方法执行前就清空，默认为  false。如果指定为 true，则在方法执行前就会清空缓存 |



# 图片base64编码

图片的base64编码就是可以将一张图片数据编码成一串字符串，使用该字符串代替图像地址url

在前端页面中常见的base64图片的引入方式：

```html
<img src="data:image/png;base64, iVBORw0.."/>
<!-- iVBORw0..是编码后的图片 -->
```

1. 优点

（1）base64格式的图片是文本格式，占用内存小，转换后的大小比例大概为1/3，降低了资源服务器的消耗；

（2）网页中使用base64格式的图片时，不用再请求服务器调用图片资源，减少了服务器访问次数。

2. 缺点

（1）base64格式的文本内容较多，存储在数据库中增大了数据库服务器的压力；

（2）网页加载图片虽然不用访问服务器了，但因为base64格式的内容太多，所以加载网页的速度会降低，可能会影响用户的体验。

说明：医院logo图片小，因此上传医院logo是可以使用base64格式保存

> 图片转换为base64字符串时，该字符串中包含大量的加号“+”，服务器在解析数据时会把加号当成连接符，转换为空格，因此我们要做一下特殊处理
>
> 因此使用数据的时候，需要将其转换回去





# 跨域问题

`No 'Access-Control-Allow-Origin'`

### 概念

出于浏览器的同源策略限制。

**同源策略**会阻止一个域的javascript脚本和另外一个域的内容进行交互。所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）

**跨域问题**，三个地方，任何一个不相同都会产生跨域，不能访问

- 访问协议：http 访问 https
- 访问地址：192.128.1.1 访问 172.11.1.1
- 访问端口：9528 访问 8201

### 解决方式

1、返回新的CorsFilter（全局跨域）

2、重写 WebMvcConfigurer（全局跨域）

3、**使用注解 @CrossOrigin**（在Controller类或方法上）（局部跨域）

4、手动设置响应头 (HttpServletResponse)（局部跨域）

5、自定web filter 实现跨域



> - 上面前两种方式属于全局 CORS 配置，后两种属于局部 CORS配置。如果使用了局部跨域是会覆盖全局跨域的规则，所以可以通过 @CrossOrigin 注解来进行细粒度更高的跨域资源控制。
> - 其实无论哪种方案，最终目的都是**修改响应头**，向响应头中添加浏览器所要求的数据，进而实现跨域



### 具体实现

#### 1、返回新的 CorsFilter(全局跨域)

在任意配置类，返回一个 新的 CorsFIlter Bean ，并添加映射路径和具体的CORS配置路径。

```java
@Configuration
public class GlobalCorsConfig {
    @Bean
    public CorsFilter corsFilter() {
        //1. 添加 CORS配置信息
        CorsConfiguration config = new CorsConfiguration();
        //放行哪些原始域
        config.addAllowedOrigin("*");
        //是否发送 Cookie
        config.setAllowCredentials(true);
        //放行哪些请求方式
        config.addAllowedMethod("*");
        //放行哪些原始请求头部信息
        config.addAllowedHeader("*");
        //暴露哪些头部信息
        config.addExposedHeader("*");
        //2. 添加映射路径
        UrlBasedCorsConfigurationSource corsConfigurationSource = new UrlBasedCorsConfigurationSource();
        corsConfigurationSource.registerCorsConfiguration("/**",config);
        //3. 返回新的CorsFilter
        return new CorsFilter(corsConfigurationSource);
    }
}
```



#### 2、重写 WebMvcConfigurer(全局跨域)

```java
@Configuration
public class CorsConfig implements WebMvcConfigurer {
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                //是否发送Cookie
                .allowCredentials(true)
                //放行哪些原始域
                .allowedOrigins("*")
                .allowedMethods(new String[]{"GET", "POST", "PUT", "DELETE"})
                .allowedHeaders("*")
                .exposedHeaders("*");
    }
}
```



#### 3、使用注解 (局部跨域)

在控制器(类上)上使用注解 @CrossOrigin:，表示该类的所有方法允许跨域。

```java
@RestController
@CrossOrigin(origins = "*")
public class HelloController {
    @RequestMapping("/hello")
    public String hello() {
        return "hello world";
    }
}
```

在方法上使用注解 @CrossOrigin:

```java
@RequestMapping("/hello")
@CrossOrigin(origins = "*")
//@CrossOrigin(value = "http://localhost:8081") //指定具体ip允许跨域
public String hello() {
    return "hello world";
}
```



#### 4、手动设置响应头(局部跨域)

使用 HttpServletResponse 对象添加响应头(Access-Control-Allow-Origin)来授权原始域，这里 Origin的值也可以设置为 “*”,表示全部放行。

```java
@RequestMapping("/index")
public String index(HttpServletResponse response) {
    response.addHeader("Access-Allow-Control-Origin","*");
    return "index";
}
```



#### 5、使用自定义filter实现跨域

首先编写一个过滤器，可以起名字为MyCorsFilter.java

```java
@Component
public class MyCorsFilter implements Filter {
  public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {
    HttpServletResponse response = (HttpServletResponse) res;
    response.setHeader("Access-Control-Allow-Origin", "*");
    response.setHeader("Access-Control-Allow-Methods", "POST, GET, OPTIONS, DELETE");
    response.setHeader("Access-Control-Max-Age", "3600");
    response.setHeader("Access-Control-Allow-Headers", "x-requested-with,content-type");
    chain.doFilter(req, res);
  }
  public void init(FilterConfig filterConfig) {}
  public void destroy() {}
}
```

在web.xml中配置这个过滤器，使其生效

```xml
<!-- 跨域访问 START-->
<filter>
 <filter-name>CorsFilter</filter-name>
 <filter-class>com.mesnac.aop.MyCorsFilter</filter-class>
</filter>
<filter-mapping>
 <filter-name>CorsFilter</filter-name>
 <url-pattern>/*</url-pattern>
</filter-mapping>
<!-- 跨域访问 END  -->
```



# EasyExcel

数据字典文件中



# Nginx反向代理

由于我们后端有很多服务模块，每个模块都有对应的访问路径与端口，为了提供统一的api接口，所以使用nginx作为反向代理服务器；

反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址

```shell
# 1、配置nginx
server {
	listen       9001;
	server_name  localhost;
       
    location ~ /hosp/ {           
        proxy_pass http://localhost:8201;
    }
    location ~ /cmn/ {           
        proxy_pass http://localhost:8202;
    }
}

# 2、调整/config/dev.env.js中的BASE_API
BASE_API: 'http://localhost:9001'

# 后续将用Spring Cloud Gateway网关，将替代nginx网关
```



# 注册中心与服务调用（Nacos）

跨模块调用接口

**例如，通过 service-hosp 远程调用 service-cmn 模块中的方法**

> hosp 中需要查找医院的等级，但是等级信息是存在数据字典中的，所以需要调用 cmn 中的方法，此时就需要使用 Nacos

实际开发中，是在不同的电脑上，需要远程调用才能解决

## 概念

注册中心就相当于调用者与被调用者之间的桥梁

## 常见的注册中心

1、Eureka（原生，2.0遇到瓶颈，停止维护）

2、Zookeeper（支持，专业的独立产品。例如：dubbo）

3、Consul（原生，GO语言开发）

4、Nacos

相对于 Spring Cloud Eureka 来说，Nacos 更强大。

Nacos = Spring Cloud Eureka + Spring Cloud Config

Nacos 可以与 Spring, Spring Boot, Spring Cloud 集成，并能代替 Spring Cloud Eureka, Spring Cloud Config。

- 通过 Nacos Server 和 spring-cloud-starter-alibaba-nacos-config 实现配置的动态变更。

- 通过 Nacos Server 和 spring-cloud-starter-alibaba-nacos-discovery 实现服务的注册与发现。



## 结构图

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202205062138770.png" alt="image-20220506213853324" style="zoom:50%;" />

## 使用

进入解压目录`sh startup.sh -m standalone`（单机模式启动）

访问：http://localhost:8848/nacos

用户名/密码：nacos/nacos

- 引入依赖
- 项目的配置文件中添加nacos服务地址

```properties
# nacos 服务地址
spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848
```

- 项目的启动类上添加注解`@EnableDiscoveryClient`



## Feign服务调用

SpringCloud 中的组件，进行调用接口

引入依赖，见 service_client 模块

```java
/**
 * 数据字典API接口
 */
// 这里的名称是nacos配置的时候配置的名称
// 被调用
@FeignClient("service-cmn")
public interface DictFeignClient {

    /**
     * 获取数据字典名称
     * 将需要调用的方法直接复制过来
     * 将路径补充完整
     * PathVariable后指定名称,必须要写
     */
    @GetMapping("/admin/cmn/dict/getName/{value}")
    public String getName(@PathVariable("value") String value);

    /**
     * 获取数据字典名称
     */
    @GetMapping("/admin/cmn/dict/getName/{dictCode}/{value}")
    public String getName(@PathVariable("dictCode") String dictCode, @PathVariable("value") String value);
}
```

在调用端 hosp 中导入cmn-client 的依赖



## 报错

`Consider defining a bean of type 'com.yienx.yygh.cmn.client.DictFeignClient' in your configuration.`

- service中的依赖未打开
- 调用端hosp启动类上加注解`@EnableFeignClients(basePackages = "com.yienx")`，该注解根据服务名去找调用的服务
	- 扫描包：如果调用的是在同一个项目中没关系，但是在不同项目中不扫描包可能会找不到

`Did you forget to include spring-cloud-starter-loadbalancer`

springboot 和 springcloud 的版本过高引起的问题

```xml
<dependency>
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-loadbalancer</artifactId>
</dependency>
```



# P91科室的属性结构显示

配合element-ui，需要将科室信息变成以下json格式形式

```json
{
    bigcode:'1'
    depname:'内科'
    children:[
    	{
    		depcode:'11'
    		depname:'普通内科'
		}
		...
    ]
}
```





# 服务网关

## 概念

API网关出现的原因是微服务架构的出现，不同的微服务一般会有不同的网络地址，而外部客户端可能需要调用多个服务的接口才能完成一个业务需求，如果让客户端直接与各个微服务通信，会有以下的问题：

（1）客户端会多次请求不同的微服务，增加了客户端的复杂性。

（2）存在跨域请求，在一定场景下处理相对复杂。

（3）认证复杂，每个服务都需要独立认证。

（4）难以重构，随着项目的迭代，可能需要重新划分微服务。例如，可能将多个服务合并成一个或者将一个服务拆分成多个。如果客户端直接与微服务通信，那么重构将会很难实施。

（5）某些微服务可能使用了防火墙 / 浏览器不友好的协议，直接访问会有一定的困难。

以上这些问题可以借助 API 网关解决。API 网关是介于客户端和服务器端之间的中间层，所有的外部请求都会先经过API 网关这一层。也就是说，API 的实现方面更多的考虑业务逻辑，而安全、性能、监控可以交由 API 网关来做，这样既提高业务灵活性又不缺安全性

## Spring Cloud Gateway

Spring Cloud Gateway旨在为微服务架构提供简单、有效和统一的API路由管理方式，Spring Cloud Gateway作为Spring Cloud生态系统中的网关，目标是替代Netflix Zuul，其不仅提供统一的路由方式，并且还基于Filer链的方式提供了网关基本的功能，例如：安全、监控/埋点、限流等

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202205211159827.png" alt="未命名文件" style="zoom:67%;" />

## 步骤：搭建server-gateway模块

### 1、配置pom.xml

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-gateway</artifactId>
    </dependency>

    <!-- 服务注册 -->
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
    </dependency>
</dependencies>

```

### 2、在resources下添加配置文件

```properties
# 服务端口
server.port=80
# 服务名
spring.application.name=service-gateway

# nacos服务地址
spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848

#使用服务发现路由
spring.cloud.gateway.discovery.locator.enabled=true

#设置路由id
spring.cloud.gateway.routes[0].id=service-hosp
#设置路由的uri;
#lb:load balance的缩写，负载均衡，直接去nacos中找服务
spring.cloud.gateway.routes[0].uri=lb://service-hosp
#设置路由断言,代理servicerId为auth-service的/auth/路径
spring.cloud.gateway.routes[0].predicates= Path=/*/hosp/**

#设置路由id
spring.cloud.gateway.routes[1].id=service-cmn
#设置路由的uri
spring.cloud.gateway.routes[1].uri=lb://service-cmn
#设置路由断言,代理servicerId为auth-service的/auth/路径
spring.cloud.gateway.routes[1].predicates= Path=/*/cmn/**

```



### 3、添加启动类

```java
package com.yienx.yygh;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class ServerGatewayApplication {
    public static void main(String[] args) {
        SpringApplication.run(ServerGatewayApplication.class, args);
    }
}

```



### 4、全局跨域解决(Gateway里)

```java
// 这个是reactive包的
import org.springframework.web.cors.reactive.UrlBasedCorsConfigurationSource;

@Configuration
public class CorsConfig {
    @Bean
    public CorsWebFilter corsFilter() {
        CorsConfiguration config = new CorsConfiguration();
        config.addAllowedMethod("*");
        config.addAllowedOrigin("*");
        config.addAllowedHeader("*");

        UrlBasedCorsConfigurationSource source = 
            new UrlBasedCorsConfigurationSource(new PathPatternParser());
        source.registerCorsConfiguration("/**", config);

        return new CorsWebFilter(source);
    }
}
// @CrossOrigin都去掉
```



### 报错

使用gateway后前端503

```properties
#发现是lb找不到，版本依赖的问题，改成端口就好了
#spring.cloud.gateway.routes[0].uri=lb://service-hosp
spring.cloud.gateway.routes[0].uri=http://localhost:8201
```

或者

```xml
<!-- 依赖中加上loadbalancer -->
<!-- 没找到依赖导致的 -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-loadbalancer</artifactId>
</dependency>
```



# Nuxt服务端渲染技术

## 服务端渲染技术

服务端渲染又称SSR (Server Side Render)是在服务端完成页面的内容，而不是在客户端通过AJAX获取数据。

服务器端渲染(SSR)的优势主要在于：**更好的 SEO**(Search Engine Optimization, 搜索引擎优化)，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。

如果应用程序初始展示 loading 菊花图，然后通过 Ajax 获取内容，抓取工具并不会等待异步完成后再进行页面内容的抓取。也就是说，如果 SEO 对你的站点至关重要，而你的页面又是异步获取内容，则你可能需要服务器端渲染(SSR)解决此问题。

另外，使用服务器端渲染，我们可以获得更快的内容到达时间(time-to-content)，无需等待所有的 JavaScript 都完成下载并执行，产生更好的用户体验，对于那些内容到达时间(time-to-content)与转化率直接相关的应用程序而言，服务器端渲染(SSR)至关重要。

> 数据操作过程在服务端完成，客户端只负责显示

## nuxt

Nuxt.js 是一个基于 Vue.js 的轻量级应用框架,可用来创建服务端渲染 (SSR) 应用,也可充当静态站点引擎生成静态站点应用,具有优雅的代码结构分层和热加载等特性。

官网网站：

https://zh.nuxtjs.org/

下载安装包

https://github.com/nuxt-community/starter-template/archive/master.zip

https://github.com/nuxt-community/starter-template

## 步骤

1、将templete中内容复制到工作区文件夹

2、修改package.json和nuxt.config.js

name、description、author（必须修改这里，否则项目无法安装，改成自己的就可以）



## 引入element-ui

1、

```shell
npm install element-ui
```

2、在plugins文件夹下创建myPlugin.js文件

```js
import Vue from 'vue'
import ElementUI from 'element-ui' //element-ui的全部组件
import 'element-ui/lib/theme-chalk/index.css'//element-ui的css
Vue.use(ElementUI) //使用elementUI
```

3、在nuxt.config.js文件中使用myPlugin.js

在build下面添加内容：不是build里面

```.js
plugins: [
	{ src: '~/plugins/myPlugin.js', ssr: false }
]
```



## 启动报错：eslint

```shell
npm init -y

npm install eslint --save-dev

./node_modules/.bin/eslint --init #初始化配置文件
```

在 .eslintrc.js中

```js
// .eslintrc.js改成如下
// https://eslint.org/docs/user-guide/configuring
module.exports = {
  root: true,
  parserOptions: {
      parser: 'babel-eslint'
  },
  env: {
      browser: true,
  },
  extends: [
      // https://github.com/vuejs/eslint-plugin-vue#priority-a-essential-error-prevention
      // consider switching to `plugin:vue/strongly-recommended` or `plugin:vue/recommended` for stricter rules.
      'plugin:vue/essential'
  ],
  // required to lint *.vue files
  plugins: [
      'vue'
  ],
  // add your custom rules here
  rules: {
      // allow async-await
      'generator-star-spacing': 'off',
      // allow debugger during development
      'no-debugger': process.env.NODE_ENV === 'production' ? 'error' : 'off'
  }
}

```

## 封装axios

nuxt中没有封装过

```shell
npm install axios
```

创建utils文件夹，utils下创建request.js

```js
import axios from 'axios'
import { MessageBox, Message } from 'element-ui'
// 创建axios实例
const service = axios.create({
    baseURL: 'http://localhost',
    timeout: 15000 // 请求超时时间
})
// http request 拦截器
service.interceptors.request.use(
    config => {
    // token 先不处理，后续使用时在完善
    return config
},
  err => {
    return Promise.reject(err)
})
// http response 拦截器
service.interceptors.response.use(
    response => {
        if (response.data.code !== 200) {
            Message({
                message: response.data.message,
                type: 'error',
                duration: 5 * 1000
            })
            return Promise.reject(response.data)
        } else {
            return response.data
        }
    }, 
    error => {
        return Promise.reject(error.response)
})
export default service

```



## 目录结构

1、资源目录 assets

 用于组织未编译的静态资源如 LESS、SASS 或 JavaScript。

2、组件目录 components

用于组织应用的 Vue.js 组件。

Nuxt.js 不会扩展增强该目录下 Vue.js 组件，即这些组件不会像页面组件那样有 asyncData 方法的特性。

3、布局目录 layouts

用于组织应用的布局组件。

4、页面目录 pages

用于组织应用的路由及视图。Nuxt.js 框架读取该目录下所有的 .vue 文件并自动生成对应的路由配置。

5、插件目录 plugins

用于组织那些需要在 根vue.js应用 实例化之前需要运行的 Javascript 插件。

6、nuxt.config.js 文件

nuxt.config.js 文件用于组织Nuxt.js 应用的个性化配置，以便覆盖默认配置。



## 使用

vue中script中的data之前

```js
// 渲染组件之前，异步获取数据
// 只在组件初始化之前调用
// params可以得到路径中的值，
// 之前是this.$route.params.
asyncData({ params, error }) {
    //调用
    return hospApi.getPageList(1,10,null)
        .then(response => {
        return {
            list: response.data.content,
            pages: response.data.totalPages
        }
    })
},
data() {
    return {
        
    }
}
```



## Note

base64处理过的图片要显示得这样

```vue
<!-- : 一定要加 -->
<img :src="'data:image/jpeg;base64,'+item.logoData"
:alt="item.hosname"
class="hospital-img">
```



## nuxt路由跳转

1、固定路由：localhost:3000/hosp/

路径固定

```js
//点击某个医院名称，跳转到详情页面中
show(hoscode) {
    window.location.href = "/hosp";
}
// 会跳转到nuxt目录下的pages中的hosp文件夹中的index.vue
```



2、动态路由：localhost:3000/hosp/2

路径不固定

```js
//点击某个医院名称，跳转到详情页面中
show(hoscode) {
    window.location.href = "/hosp" + hoscode;
}
// 会跳转到nuxt目录下的pages中的hosp文件夹中的
// _参数名.vue
// 此处为_hoscode.vue
```

 

# JWT生成Token

## 简介

JWT 就是一种生成 token 的规则。

JWT（Json Web Token）是为了在网络应用环境间传递声明而执行的一种基于 JSON 的开放标准。

JWT 最重要的作用就是对 token信息的**防伪**作用。 

## JWT 的原理

一个 JWT 由三个部分组成：**公共部分**、**私有部分**、**签名部分**。

最后由这三者组合进行 base64 编码得到 JWT。

### 1、 公共部分

主要是该 JWT 的相关**配置参数**，比如签名的**加密算法**、**格式类型**、**过期时间**等等。

Key=YIENX

### 2、 私有部分

用户自定义的内容，根据实际需要真正要封装的信息。

userInfo{用户的Id，用户的昵称nickName}

### 3、 签名部分

SaltiP: 当前服务器的Ip地址!{linux 中配置代理服务器的ip}

主要用户对JWT生成字符串的时候，进行加密{盐值}

最终组成 key+salt+userInfo è token!

base64编码，并不是加密，只是把明文信息变成了不可见的字符串。但是其实只要用一些工具就可以把base64编码解成明文，所以不要在JWT中放入涉及私密的信息。

## 使用

```xml
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt</artifactId>
</dependency>
```

编写 JwtHelper 类

```java
public class JwtHelper {
    // 过期时间，ms
    private static final long tokenExpiration = 24*60*60*1000;
    // 签名密钥
    private static final String tokenSignKey = "123456";

    // 根据参数生成token
    public static String createToken(Long userId, String userName) {
        String token = Jwts.builder()
                .setSubject("YYGH-USER") // 分类
                .setExpiration(new Date(System.currentTimeMillis() + tokenExpiration))
                .claim("userId", userId)
                .claim("userName", userName)
                .signWith(SignatureAlgorithm.HS512, tokenSignKey)
                .compressWith(CompressionCodecs.GZIP)
                .compact();
        return token;
    }

    // 根据token字符串得到用户id
    public static Long getUserId(String token) {
        if(!StringUtils.hasLength(token)) return null;

        Jws<Claims> claimsJws = Jwts.parser().setSigningKey(tokenSignKey).parseClaimsJws(token);
        Claims claims = claimsJws.getBody();
        Integer userId = (Integer)claims.get("userId");
        return userId.longValue();
    }

    // 根据token字符串得到用户名
    public static String getUserName(String token) {
        if(!StringUtils.hasLength(token)) return "";

        Jws<Claims> claimsJws = Jwts.parser().setSigningKey(tokenSignKey).parseClaimsJws(token);
        Claims claims = claimsJws.getBody();
        return (String)claims.get("userName");
    }
    
    // test
    public static void main(String[] args) {
        String token = JwtHelper.createToken(1L, "lucy");
        System.out.println(token);
        System.out.println(JwtHelper.getUserId(token));
        System.out.println(JwtHelper.getUserName(token));
    }
}

```



# 阿里云短信验证服务

短信验证的服务不需要连接数据库

所以要在启动类上排出自动加载数据源连接配置

```java
@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)
//取消数据源自动配置
```

依赖

```xml
<dependencies>
    <dependency>
        <groupId>com.aliyun</groupId>
        <artifactId>aliyun-java-sdk-core</artifactId>
    </dependency>
</dependencies>
```



```java
// 添加配置类
@Component
public class ConstantPropertiesUtils implements InitializingBean {

    @Value("${aliyun.sms.regionId}")
    private String regionId;

    @Value("${aliyun.sms.accessKeyId}")
    private String accessKeyId;

    @Value("${aliyun.sms.secret}")
    private String secret;

    public static String REGION_Id;
    public static String ACCESS_KEY_ID;
    public static String SECRECT;

    @Override
    public void afterPropertiesSet() throws Exception {
        REGION_Id=regionId;
        ACCESS_KEY_ID=accessKeyId;
        SECRECT=secret;
    }
}

```





# 用户信息记录在Cookie中

后段可以直接存入cookie

前端必须使用js-cookie

`npm install js-cookie`



# 全局事件

目前登录层在myheader组件里面，登录按钮也在同一个组件里面，我们点击登录，调用showLogin()方法即可

目前的问题是，在预约挂号页面，选择科室去挂号时需要判断当前是否登录，

如果登录可以进入下一个页面；如果没有登录需要显示登录层；

那么这个问题怎么解决呢，我们不能直接调用头部登录方法，目前的组件是包含在nuxt里面的，可以注册一个全局登录事件，当需要登录层时，发送一个登录事件，头部监听登录事件，然后我们触发登录按钮的点击事件即可打开登录层

```js
// 修改myheader.vue组件
import Vue from 'vue'
// 注册与监听事件
mounted() {
    // 注册全局登录事件对象
    window.loginEvent = new Vue();
    // 监听登录事件
    // 在别的页面调用loginDialogEvent方法
    // 则会触发id为loginDialog的事件
    loginEvent.$on('loginDialogEvent', function () {
        document.getElementById("loginDialog").click();
    })
    // 触发事件，显示登录层：
    // 在别的页面调用使用这个
    // loginEvent.$emit('loginDialogEvent')
}
```



# 用户认证与网关整合

### 思路

1. 所有请求都会经过服务网关，服务网关对外暴露服务，在网关进行统一用户认证；

2. 既然要在网关进行用户认证，网关得知道对哪些 url 进行认证，所以我们得对 url 制定规则

3. Api接口异步请求的，我们采取 url 规则匹配，如：`/api/**/auth/**`，如凡是满足该规则的都必须用户认证

### 流程

1、在服务网关添加 filter 

```java
@Component
public class AuthGlobalFilter implements GlobalFilter, Ordered {

    private AntPathMatcher antPathMatcher = new AntPathMatcher();

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();
        String path = request.getURI().getPath();
        System.out.println("==="+path);

        //内部服务接口，不允许外部访问
        if(antPathMatcher.match("/**/inner/**", path)) {
            ServerHttpResponse response = exchange.getResponse();
            return out(response, ResultCodeEnum.PERMISSION);
        }

        Long userId = this.getUserId(request);
        //api接口，异步请求，校验用户必须登录
        if(antPathMatcher.match("/api/**/auth/**", path)) {
            if(StringUtils.isEmpty(userId)) {
                ServerHttpResponse response = exchange.getResponse();
                return out(response, ResultCodeEnum.LOGIN_AUTH);
            }
        }
        return chain.filter(exchange);
    }

    @Override
    public int getOrder() {
        return 0;
    }

    /**
     * api接口鉴权失败返回数据
     * @param response
     * @return
     */
    private Mono<Void> out(ServerHttpResponse response, ResultCodeEnum resultCodeEnum) {
        Result result = Result.build(null, resultCodeEnum);
        byte[] bits = JSONObject.toJSONString(result).getBytes(StandardCharsets.UTF_8);
        DataBuffer buffer = response.bufferFactory().wrap(bits);
        //指定编码，否则在浏览器中会中文乱码
        response.getHeaders().add("Content-Type", "application/json;charset=UTF-8");
        return response.writeWith(Mono.just(buffer));
    }

    /**
     * 获取当前登录用户id
     * @param request
     * @return
     */
    private Long getUserId(ServerHttpRequest request) {
        String token = "";
        List<String> tokenList = request.getHeaders().get("token");
        if(null  != tokenList) {
            token = tokenList.get(0);
        }
        if(StringUtils.hasLength(token)) {
            return JwtHelper.getUserId(token);
        }
        return null;
    }
}


```



### 调整前端

请求服务器端接口时我们默认带上token，需要登录的接口如果token没有或者token过期，服务器端会返回208状态，然后发送登录事件打开登录弹出层登录

修改utils/request.js文件



# OAuth2微信登录

## OAuth2 解决的问题：

### 1、开放系统间授权  

资源拥有者 -- 客户应用 -- 受保护的资源

- 用户名密码复制

	适用于同一公司内部的多个系统，不适用于不受信的第三方应用

- 通用开发者 Key 

	适用于合作商或者授信的不同业务部门之间

- 颁发令牌

	OAuth2约定了令牌的解决方案，但是令牌的生成还是得用别的，如 JWT 

### 2、单点登录问题

在其中某个模块登陆，在其他模块也可以登陆

比如：在百度文库登陆后，在贴吧也可以直接登陆

