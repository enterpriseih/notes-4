# 面试题目

## 一、int a = 1 存放在哪？

明确1是字面量，a是变量也是符号引用。

-128 ～ 127都在常量池中，超出的再integer

**a是成员变量**：符号引用a和字面量1都是存储在常量池中的，也即是方法区中。

**a是局部变量**：符号引用a和字面量1都是在栈中的局部变量表中。

## 二、一个对象从加载到JVM，再到被GC清除，都经历了什么过程？

1. 用户创建一个对象，JVM 首先到方法区找对象的类型信息，然后创建对象。

2. JVM 要实例化一个对象，首先要在堆中创建一个对象 -> 半初始化状态

3. 对象首先会分配在堆内存的Eden中，然后经历一次Minor GC，对象如果存活，就会进入S区；在后续的每次 GC 中，如果对象一直存活，就会在 S 区来回拷贝，每移动一次，年龄加 1。-> 年龄超过15就会转入Old。

4. 当方法执行结束后，栈中的指针会先移除掉。

5. 堆中的对象，经过 Full GC，就会被标记为垃圾，然后被 GC 线程清理掉。

## 三、G1垃圾回收整体流程

1. **初始标记**：标记出 GCRoot 直接引用的对象。STW
2. **标记 Region**：通过 RSet 标记出上一个阶段标记的 Region 引用到的 Old 区 Region。
3. **并发标记**：与CMS类似，只是遍历的不是Old区，而是第二步标记出来的Region。
4. **重新标记**：类似CMS。
5. **垃圾清理**：与CMS不同的是，G1 可以采用复制算法，直接将整个 Region 中的对象复制到另一个 Region。而这个阶段，G1 只选择垃圾较多的 Region 来清理，并不是完全清理。

# Java源程序编译运行过程

Java 源文件 → 编译器 → JVM可以理解的字节码文件 .class → JVM解释器/JIT编译器 →机器可以执行的二进制机器码

> 字节码文件
>
> - 不专对特定机器，无需重新编译就可以在不同的机器上运行
> - 以一个字节 8bit 为最小单位储存

# JVM运行机制

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207161425580.jpg" alt="第02章_JVM架构-简图" style="zoom:70%;" />



**线程**

- **线程是进程中执行运算（资源分配）的最小单位**，是进程的一个实体
- 一个进程就是一个程序，多进程是指操作系统能同时运行多个任务（程序）

**执行引擎**

- 将字节码指令解释/编译为对应平台上的本地机器指令

# 预备知识：常量池

存放

- 字面量
- 符号引用

<br>

1. **(Class)常量池**
  - Class 文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant Pool Table），存放编译期生成的各种`字面量`和`符号引用`
  - 每个class文件都有一个class常量池
2. **运行时常量池**（方法区里的重要结构）
  - 运行时常量池存在于内存中，也就是`class常量池被加载到内存之后的版本`，不同之处是：它的字面量可以动态的添加(String.intern())，符号引用可以被解析为直接引用
  - JVM在执行某个类的时候，必须经过加载、连接、初始化，而连接又包括验证、准备、解析三个阶段。而当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，由此可知，`运行时常量池也是每个类都有一个`。在解析阶段，会把`符号引用替换为直接引用`，解析的过程会去`查询字符串常量池`，也就是我们上面所说的StringTable，以保证运行时常量池所引用的字符串与字符串常量池中是一致的。

> 字符串常量池
>
> - ≤1.6 方法区中
> 	- String Pool里放的都是字符串常量
> - ≥1.7 移到了堆中
> 	- 由于String#intern()发生了改变，因此String Pool中也可以存放放于堆内的字符串对象的引用
> - 字符串常量池中的字符串只保存一份

# 对象

```java
public static void main(String[] args) {
    Customer cust = new Customer();
}
```



<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207152117217.jpg"/>

## 对象的实例化

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202203311610240.png" alt="第10章_对象的实例化" style="zoom:50%;" />

### 内存分配

1、指针碰撞

已用内存和未使用内存是分开的，中间由指针隔开

2、空闲列表

有个列表来描述哪些地址的内粗是空闲的

> 内存分配是哪种方式还得看GC的方式，有的GC会造成碎片化就是用空闲列表。

### 判断对应的类是否加载、初始化（加载类元信息）

虛拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。（即判断类元信息是否存在）。

如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader+包名＋类名为key进行查找对应的.class 文件。如果没有找到文件，则抛出ClassNotFoundException 异常，如果找到，则进行类加载，并生成对应的Class 类对象

> new是开始，构造器后才构建成功。

## 对象的内存布局

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207152057836.jpg" alt="第10章_内存布局" />

### 对象头

- 运行时元数据（MarkWord）

	- 哈希值
	- GC分代年龄
	- 锁状态标志
	- 线程持有的锁
	- 偏向线程ID
	- 偏向时间戳

- 类型指针

	指向类元数据InstanceKlass，确定该对象所属的类型
	
- 数组长度

  如果有的话，32bit

> 对象头中的Mark Word（标记字）主要用来**表示对象的线程锁状态**，另外还可以用来配合GC、存放该对象的hashCode；

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207161444658.png"  />

> 为什么从Young GC的对象最多经历15次Young GC还存活就会进入Old区（年龄是可以调的，默认是15）?
>
> 因为用了4个bit去表示分代年龄，那么能表示的最大范围就是0-15。所以这也就是为什么设置新生代的年龄不能超过15，可以通过-XX:MaxTenuringThreshold去调整（最大值为15）

[对象头](https://blog.csdn.net/sumengnan/article/details/125035218)

[锁升级与对象头](https://zhuanlan.zhihu.com/p/537852119)

1、对于偏向锁而言， **一旦在对象头中设置过hashcode， 那么进入同步块时就不会进入偏向锁状态**，会直接跳到轻量级锁，毕竟偏向锁里没有存放hashcode的地方。

2、轻量级锁中，除了锁状态标记位，其他的都变成了一个栈帧中lockRecord记的地址。分代年龄、hashcode等固有属性。这些信息会被存储到对应线程栈帧中的**lockRecord**中。

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207161501955.jpg" alt="img" style="zoom:67%;" />

3、重量级锁中，对象头中的markwod，和轻量级锁中的处理类似， 被存入objectMonitor对象的header字段中。

## 对象的访问定位

### 1、直接访问（HotPot采用）

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207152136151.jpg" alt="第10章_方式2：使用直接指针访问" style="zoom:45%;" />

### 2、句柄访问

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207152134231.jpg" alt="第10章_方式1：句柄访问" style="zoom:67%;" />

需要专门开辟区间存放句柄，而且效率慢，因为需要先找到句柄，再从句柄找到对象实例数据。

优点：reference中存放稳定句柄地址，对象被移动时只会改变句柄中实例数据指针即可，reference本身不需要被修改。

# [JVM内存区域](./JVM内存区域.md)

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202203301347028.png" alt="image-20220330134754626" style="zoom:40%;" />

# JVM类加载机制

加载、验证、准备、解析、初始化

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202203301024818.png" alt="image-20220330102400457" style="zoom:67%;" />

1. 加载

	- 这个阶段会在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的入口

2. 验证

	- 确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求

3. 准备

	- 在方法区中分配这些变量所使用的内存空间

	```java
	public static int i = 8080;
	// 变量在准备阶段的默认值为0，在编译（初始化）阶段才会显式赋值8080
	public static final int i =8080;
	// final在准备阶段就会赋值
	```

4. 解析

	- 虚拟机将常量池中的符号引用替换为直接引用的过程
		- 符号引用：引用的目标不一定要加载在内存中
		- 直接引用：引用的目标必定已经在内存中了

5. 初始化

	TIP：不会执行初始化的情况

	- 通过子类引用父类的静态字段，只会触发父类的初始化
	- 定义对象数组
	- 通过类名获取 Class 对象
	- 通过 Class.forName 加载指定类时，指定参数 initialize = false
	- 通过 ClassLoader 默认的 loadClass 方法


## 类加载
**启动类加载器 Bootstrap ClassLoader**

- 加载 **$JAVA_HOME/jre/lib** 下的 jar 包，如 rt.jar

**扩展类加载器 Extension ClassLoader**

- 加载\$JAVA_HOME/jre/lib/*.jar 、-Djava.ext.dirs 参数指定目录下的 jar 包、**$JAVA_HOME/jre/lib/ext/classes** 目录下的 class

**应用程序类加载器 Application ClassLoader**

- 加载用户路径 classpath 中指定的 jar 包及目录中的 class

- 自定义类加载器：程序员自己开发一个类继承 java.lang.ClassLoader， 定制类加载方式
	- 加载用户指定目录下的，挂载应用类加载器

### 双亲委派机制

- 当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求**委派给父类**去完成，
- 每一个层次类加载器都是如此，因此所有的加载请求都应该传送到**启动类加载器**中，
- 只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202203301035804.png" alt="image-20220330103519857" />

> **TIP**
>
> - **避免类的重复加载**：父加载器加载了一个类，就不必让子加载器再去查找了。同时也保证了在整个 JVM 范围内全类名是类的唯一标识。
> 	- 比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object 对象。
> - **安全机制**：避免恶意替换 JRE 定义的核心 API
> 	- 比如自定义一个 java.lang.String 类，最终加载的还是启动类加载器加载的String



<br>

# 垃圾回收机制

作用区域：方法区和堆，重点是堆

从次数上

- 频繁收集Young区
- 较少收集Old区
- 基本不动Perm区

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/GC202204051338554.png" alt="image-20220405133753426" style="zoom: 33%;" />

## 一、标记阶段：如何判断对象死亡

### 1、引用计数法

记录对象被引用的情况

引用一次计数+1，解除引用-1；

可能会循环引用，导致计数器无法归零

### 2、可达性分析、根搜索法 GC Roots

`解决循环引用的问题，防止内存泄漏`

核心原理：判断一个对象，是否存在从『堆外』到『堆内』的引用。

以`根对象集合（GC Roots）`为起点，从上至下的方式搜索被根对象集合所连接的目标对象是否可达。搜索的路径称为`引用链（Reference Chain）`

- 如果在 GC Roots 和一个对象之间没有可达路径，则称该对象不可达
- 不可达对象经过至少两次标记后，如果仍是可回收对象，则将面临回收

> **GC root设置为所有Java线程当前活跃的栈帧里指向GC堆里的对象的引用**

### 3、GC Roots 对象包括

- **Java栈中引用的对象**
	- 各个线程被调用方法中使用的参数、局部变量等
- **本地方法栈中引用的对象**
- 方法区中
	- 类引用类型**静态变量/类变量引用的对象**（1.7之后堆中）
	- **常量引用的对象**：字符串常量池里的引用的对象（1.7之后堆中）
- **被synchronized持有的对象**
- 基本数据类型对应的Class对象，常驻异常对象、系统类加载器

根据选择的GC收集器和当前回收的内存区域不同，还可以有其他对象“临时性”加入，比如：分代收集和局部回收

> **TIP**
>
> Root 采用栈方式存放变量和指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个 Root

由于枚举根节点需要停顿，所以GC进行时必须Stop The World (STW，暂停所有线程)

### 方法区的回收

> **NOTE**: 方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？
>
> 判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 “无用的类” ：
>
> - 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
> - 加载该类的 ClassLoader 已经被回收。
> - 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
> 	

## 对象的finalization机制

Java语言提供了对象终止（finalization）机制来允许开发人员提供`对象被销毁之前的自定义处理逻辑`

**垃圾回收对象之前，总会先调用这个对象的finalize()方法**

finalize允许在子类中被**重写**，用于在对象回收时进行资源释放，比如：关闭文件、套接字、数据库连接等

**不要主动调用finalize，应交给垃圾回收**，因为

- 在finalize时可能会导致对象复活
- finalize的执行时间没有保障，完全由GC线程决定，极端下，若不GC，则finalize不会执行
- 一个糟糕的finalize会严重影响GC性能

### 1、JVM中对象的三种状态

- 可触及的：可达
- 可复活的：不可达，但是对象可能在finalize中复活
- 不可触及的：没复活；不可触及的对象不可能被复活，因为`finalize只会被调用一次`

### 2、GC Roots中的两次标记

1. 没有引用链，第一次标记
2. 判断是否有必要执行finalize
	- 没有重写finalize、或finalize已经被调用过了，则对象不可触及
	- 重写了finalize且也没调过，JVM会创建一个低优先级的Finalizer线程触发finalize方法
	- 若finalize中建立了联系，但是之后再次断开引用链，finalize不会再触发

## 二、清除阶段：垃圾回收算法

> **清除**
>
> 不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里，下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放

### 1、标记-清除（Mark-Sweep）

**标记**：从根节点开始遍历，标记所有被引用的对象（可达对象）

**清除**：对堆内存从头到尾进行线性遍历，回收没有标记的对象

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204011000580.png" alt="第14章_标记-清除算法" style="zoom:33%;" />

**缺点**

- 效率不算高
- 清理出来的空间内存不连续，`内存碎片化严重`，后续可能发生大对象找不到可用空间
- 需要维护一个空闲列表

### 2、复制（Copying）

为了解决标记清除的内存碎片化的缺陷提出

将**内存空间分为两块**，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存大角色，完成垃圾回收

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204011015298.png" alt="第14章_复制算法" style="zoom:33%;" />

**优点**

- 实现简单，运行搞笑
- 空间连续，不会碎片

**缺点**

- 需要两倍大空间
- 存活对象多多话，效率会低

**特别的**

特别适合垃圾对象很多，存活对象很少的场景，例如：Young区的survior0和survior1

### 3、标记-压缩/整理（Mark-Compact）

结合以上两种算法，避免缺陷

标记后将存活对象移向内存的一端，按序排放，然后清除端边界外的对象

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204011022855.png" alt="第14章_标记-压缩算法" style="zoom:33%;" />

**缺点**

- 效率低于复制算法
- 移动对象时，如果对象被其他对象引用，则还需要调整引用的地址
- 移动过程中，需要全程暂停用户应用程序

### 分代收集

根据不同分代区域，选择合适的算法

- 新生代：生命周期短，存活对象少
	- 使用复制算法，所以存在from和to区
- 老年代：区域大，生命周期长，回收频率不高
	- 使用标记清除和标记压缩的混合实现
		- Mark阶段的开销与存活对象的数量成正比
		- Sweep阶段的开销与所管理区域的大小成正比
		- Compact阶段的开销与存活对象的数据成正比

### 分区收集

将整个堆空间划分为连续的不同小区间region，每个小区间独立使用，独立回收，可以控制一次回收多少个小区间

### 增量收集

如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿（STW），那么就可以**让垃圾收集线程和应用程序线程交替执行**。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。

总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过`对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。`

**缺点**：交替执行，系统吞吐量下降

## 垃圾回收的相关概念

### 1、Systenm.gc()的理解

默认情况下，System.gc()或者Runtime.getRuntime().gc()的调用，会显式触发Full GC，同时对老年代和新生代进行回收，**尝试释放**被丢弃对象的内存。

System.gc()有个免责声明，**无法保证对垃圾收集器的调用**。仅仅是建议回收。

### 2、内存溢出和内存泄露

#### a>内存溢出OutOfMemoryError

**内存溢出是由于没被引用的对象（垃圾）过多造成JVM没有及时回收**，导致的内存溢出。

或虚拟机堆内存设置不够。

具体原因

- 是否应用中的类中和引用变量过多使用了Static修饰，如public staitc Student s；
- 是否应用中使用了大量的递归（递归中有新建对象）
- 检查是否有数组，List，Map中存放的是对象的引用而不是对象，因为这些引用会让对应的对象不能被释放
- 检查是否使用了“非字面量字符串进行 + ”的操作。因为 String 类的内容是不可变的，每次运行 " + " 就会产生新的对象，如果过多会造成新 String 对象过多，从而导致 JVM 没有及时回收而出现内存溢出。

```java
String s1 = "My name";
String s2 = "is";
String s3 = "xuwei";
String str = s1 + s2 + s3 +.........;
// 这是会容易造成内存溢出的

String str =  "My name" + " is " + " xuwei" 
    + " nice " + " to " + " meet you"; 
// 但是这种就不会造成内存溢出。
// 因为这是”字面量字符串“，在运行"+"时就会在编译期间运行好。
// 不会按照JVM来执行的。
```

> OOM之前一定会触发GC，不够才会OOM

#### b>内存泄漏Memory Leak

`对象不会再被程序用到，但是GC又不能回收`

由于 Java 中采用可达性分析，不存在因为循环引用不能被GC的问题。

**⻓⽣命周期的对象持有短⽣命周期对象的引⽤就很可能发⽣内存泄露**，尽管短⽣命周期对象已经不再需要，但是因为⻓⽣命周期对象持有它的引⽤⽽导致不能被回收

例如：

- 一个**外部类的实例对象**的方法**返回**了一个**内部类的实例对象**，这个内部类对象被长期引用，**即时外部类不再使用**，由于内部类还在使用的原因，这个**外部类对象不能够被回收**
- 缓存系统：**加载了一个对象放在缓存中**（例如放在一个全局map对象中），但是一直不用，这个对象一直被缓存引用却没被使用
- 单例模式：单例的生命周期和应用程序一样长，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象不能被回收
- 一些提供close的资源未被关闭，GC也不会回收

### 3、Stop The World

GC过程中，产生应用程序的停顿，停顿时整个应用程序线程都会被暂停，没有任何响应

所有GC器都会发生STW，就算G1也会，只是时间被缩短了很多

### 4、垃圾回收的并行与并发

并发

- 多个事情，在**同一时间段内同时发生**（因为**时间片快速切换**）
- 多个任务之间时互相抢占资源

并行

- 多个事情，在**同一时间点上同时发生**
- 多个任务之间不互相抢占资源

> 只有在多CPU或者一个CPU多核多情况下，才会发生并行
>
> 否则，看似同时发生的事情，其实都是并发
>
> 并行一定是并发，并发不一定是并行

**垃圾回收中**

并行（Parallel）

- 多条垃圾回收器并行工作

串行（Serial）

- 一条垃圾回收器

并发（Concurrent）

- 用户线程和垃圾回收线程同时执行（不会是完全并行，会交替执行）

### 5、安全点与安全区域

**安全点**：并非所有地方都能停顿开始GC，只有特定位置才能停顿下来开始GC

如何在GC发生时，如何保障所有线程都跑到最近的安全点停顿下来呢？

- **抢占式中断**（没有虚拟机采用）

	首先中断所有线程，如果有线程不在安全点，就回复线程，让线程跑到安全点

- **主动式中断**

	设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果为真，则将自己中断挂起

**安全区域**

在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的，是扩展了的安全点

### 6、Java的四类引用类型 — 强软弱虚

#### 强引用 — 不回收

在 Java 中最常见(99%)的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。

当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到 JVM 也不会回收。

因此强引用是`造成 Java 内存泄漏`的主要原因之一。

#### 软引用 — 内存不足即回收

软引用需要用 SoftReference 类来实现，对于**只有软引用的对象**来说，当系统内存足够时它不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中。

#### 弱引用 — 发现即回收

弱引用需要用 WeakReference 类来实现，它比软引用的生存期更短，对于**只有弱引用的对象**来说，只要垃圾回收机制一运行，不管 JVM 的内存空间是否足够，总会回收该对象占用的内存。

> 软、若都适合保存缓存数据

#### 虚引用 — 对象回收跟踪

虚引用需要 PhantomReference 类来实现，它不能单独使用，必须和引用队列联合使用。虚引用的主要作用是跟踪对象被垃圾回收的状态。

当准备回收一个对象时，如果发现还有虚引用，会在回收对象前，将这个虚引用加入引用队列，可以通过扫描队列来**通知对象的回收情况**等；这个队列是在创建虚引用的时候一同创建的。

```java
Object obj = new Object();
ReferenceQueue<Object> rq = new ReferenceQueue<Object>();
PhantomReference<Object> pf = new PhantomReference<Object>(obj,rq);
obj=null;
System.out.println(pf.get());//永远返回null
System.out.println(pf.isEnqueued());//返回是否从内存中已经删除
System.gc();
TimeUnit.SECONDS.sleep(6);
System.out.println(pf.isEnqueued());
        
null
false
true
```

<br>

补：终结器引用

用于实现对象的finalize()方法，配合引用队列使用

## 三、垃圾回收器

### 分类

线程数：

- 串行
- 并行：只要并行就会STW

工作模式：

- 并发式：交替进行，尽量减少停顿时间
- 独占式：一旦运行，就停止应用程序中所有用户线程

碎片处理方式：

- 压缩式：回收后，堆存活对象进行压缩整理，消除回收后的碎片
	- 再分配对象空间使用：指针碰撞
- 非压缩式：不进行压缩整理
	- 再分配对象空间使用：空闲列表

工作的内存区间：新生代和老年代

### 性能指标

- 吞吐量：运行用户代码的时间C占总运行时间M的比例 C/M
- 暂停时间/延迟：执行垃圾收集时，程序的工作线程被暂停的时间N = M - C
- 内存占用：Java堆区所占内存大小

> 吞吐量优先：会增加每次暂停时间，保证垃圾回收完，减少暂停的次数
>
> - 后台运算场景
>
> 暂停时间有限：会增加暂停次数，多次暂停区回收
>
> - 于用户交互的场景

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204042216784.png" alt="第17章_吞吐量与暂停时间" style="zoom: 33%;" />

### 组合关系

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204042143693.png" alt="第17章_垃圾收集器组合" style="zoom: 33%;" />

连线表示可以搭配使用

Serial Old 作为 CMS 出现“Concurrent Mode Failure”失败后的后备预案

红色虚线：JDK8弃用，JDK9移除

绿色虚线：JDK14弃用

青色框框：JDK14删除

选择针对具体应用最合适的收集器

> G1：整堆收集器

### 1、Serial回收器：串行、响应速度优先

Serial：复制算法、串行回收、STW机制（收集时必须暂停其他工作线程）

Serial Old：串行、STW、标记-压缩

优势：简单高效

运行在Client模式下的默认收集器

可以手动指定

### 2、ParNew回收器：并行、响应速度优先

Serial的多线程版本；Par并行，New新生代

复制算法、STW机制

很多JVM运行在Server模式下的新生代的默认

可以手动指定、设置线程数量

### 3、Parallel回收器：吞吐量优先、并行

Parallel Scavenge：复制、并行、STW

- 与ParNew相比，可以达到可控制的吞吐量，其`自适应调节策略`（动态调节）是重要区别

使用环境：

- 后台运算，不需要太多交互
- 批量处理、订单处理、工资支付、科学计算

Parallel Old：标记-压缩、并行、STW

Java8中默认

可以手动指定（新生代的和老年代的会互相激活）、设置年轻代线程数、最大停顿时间、垃圾收集时间占总时间的比例、启动/关闭自适应调节策略

### 4、CMS回收器：低延迟（响应速度优先）、并发

Concurrent-Mark-Sweep、强交互应用、标记清除、尽**可能缩短停顿时间**、也会有STW时间

HotSpot中第一款真正意义上的**并发收集器**

#### a>工作机制过程

- **初始标记**：暂停所有的工作线程（很快），标记一下 GC Roots 能直接关联的对象。
- **并发标记**：进行 GC Roots 跟踪的过程，和用户线程一起工作，`不需要暂停工作线程`。用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引 用更新的地方。
- **重新标记**：为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程。
- **并发清除**：清除 GC Roots 不可达对象（即未标记的区域），和用户线程一起工作，`不需要暂停工作线程`。

由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户线程一起并发工作，所以总体上来看CMS 收集器的内存回收和用户线程是一起并发地执行。

> **为什么低延迟**：由于工作机制，耗时的可以一起工作，不耗时的STW

#### b>优点

并发收集、低延迟

#### c>弊端

- **会产生内存碎片**（标记清除）
	- 为什么不标记整理？标记整理的时候，用户线程无法继续执行
- **对CPU资源非常敏感**：并发阶段不会导致用户停顿，但是会因为占用线程而导致程序变慢
- **无法处理浮动垃圾**：并发标记阶段如果产生新的垃圾对象，CMS无法对其进行标记，会导致无法被及时回收，只能下一次
- CMS运行期间预留的内存无法满足程序需要，就会“**Concurrent Mode Failure**”，而后会临时启用Serial Old来收集，Serial Old还是最差的性能

#### d>参数设置

指定回收任务：会默认打开ParNew

设置堆内存使用率的阈值，到达阈值开始回收

指定执行完FullGC后进行压缩整理、还可以设置多少次FullGC后进行压缩整理

设置CMS线程数

### Serial、Parallel、CMS有什么不同？

最小化地使用内存和并行开销：Serial

最大化应用程序的吞吐量：Parallel

最小化GC的中断或停顿时间：CMS

### 5、G1回收器：区域化分代式、优先级区域回收、响应速度优先

Garbage First

目标：**在低延迟可控的情况下获得尽可能高的吞吐量**

- 侧重于回收垃圾最大量的区间，所以叫Garbage First

JDK9 之后的默认，取代了 CMS 及 Parallel + Parallel Old组合

JDK8 中需要 -XX:+UseG1GC 来启动

#### 回收算法

垃圾回收算法：复制算法

筛选回收算法：

- 在G1收集器后台维护了一个优先列表，每次根据允许的收集时间，选择回收价值最大的Region。
- 比如在同等大小的两个Region下，回收一个需要100ms，一个需要50ms，那么G1肯定会优先回收那个50ms的。
- 保证了在**有效时间内能回收更多的堆空间**，回收时间就是复制的时间，要复制的存活对象越多，回收时间就越长，回收的效益就越低，被回收的优先级就越低。

#### a、优势

- **并行与并发**
	- G1能充分利用CPU、多核的环境优势来缩短STW停顿时间，部分其他收集器需要STW的区域，G1也可以并发执行。
- **分代收集**
	- 把堆内存划分成很多不相关的区域Region（物理上不连续），使用不同的Region来表示Eden、to、from、old区；

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/JVM202204051351656.jpeg" alt="IMG_A07C135AC2E1-1" style="zoom:50%;" />

- **空间整合**
	- 回收以Region为基本单位，**Region之间是复制算法**，但**整体**上可以看作是**标记压缩**，**避免碎片化**
- **可预测的停顿时间模型**（软实时 soft real-time）
	- 用户可通过-XX:MaxGCPauseMillis参数设置最大停顿时间，不能设置的太小，否则每一次minor gc时间过短，收集的垃圾太少，容易触发full gc。
	- 让使用者明确指定一个长度为 M 的时间片段内，消耗在 GC 的时间不超过 N  
	- 分区后，可以选择部分region回收
	- 后台有个优先级列表，根据允许的收集时间，**优先回收价值最大的Region**（回收可获得的空间大小及时间），获取**尽可能高的收集效率**
	- 想比与CMS，G1未必能做到CMS在最好情况下的延迟时间，但是最差情况下性能更好

#### b、参数设置

指定G1、每个Region的大小、最大GC停顿时间指标、STW时GC线程数、并发标记的线程数、触发并发GC周期的java堆占用率

#### c、适用场景

**针对具有大内存、多处理器的机器**；在普通大小的堆里表现不是那么惊艳

比CMS效果好的情况

- 超过50%的堆被活动数据占用
- 对象分配频率或年代提升频率变化很大
- GC停顿时间过长

> 缺点
>
> G1 需要记忆集 (具体来说是卡表)来记录新生代和老年代之间的引用关系，这种数据结构在 G1 中需要占用大量的内存，可能达到整个堆内存容量的 20% 甚至更多。而且 G1 中维护记忆集的成本较高，带来了更高的执行负载，影响效率。

#### d、分区Region

Region的身份不是固定的，谁占用就是谁

H区主要用于存储大对象，超过0.5个Region就放到H区；一个放不下就找连续的H区；实在不行就FullGC

**每个Region使用指针碰撞的方式存放数据**

#### e、回收过程

1. **年轻代GC**（Young GC）

2. **并发标记过程**（Concurrent Marking）并伴随一次YGC

3. **混合回收**（Mixed GC）：包括年轻代GC和老年代GC

- （如有需要，也存在FullGC，针对GC的评估失败提供了一种失败保护机制，强力回收）

顺时针：young gc -> young gc + concurrent mark -> mixed gc

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/G202204051410567.png" alt="第17章_G1-GC垃圾回收过程" />

**Remembered Set**

一个region中的对象可能被其他region中的对象引用，是否需要扫描整个堆，其他分代收集器也存在这样的问题，如何在回收新生代的时候不同时扫描老年代？

解决方法：

无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描：

> - 每个region都有一个对应的remembered set记忆集
> - 每次Reference类型数据写操作时，都会产生一个write Barrier暂时中断操作；
> - 然后**检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region**（其他收集器：检查老年代对象是否被新生代对象引用）
> - 如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered set中；
> - 当进行垃圾收集时，将Remembered set加入GC根节点的枚举范围：就可以保证不进行全局扫描，也不会有遗漏。

##### 年轻代GC

1. Eden满了，会出发YGC，通过复制算法进行垃圾回收
2. STW，将标记的region中的存活对象拷贝到survivor
3. 回收eden对应的region

> YGC的时候会做的事情
>
> - 更新RSet记忆集：保证Rset中的数据准确性
> 	- RSet需要线程同步，开销大，不能实时更新，需要一个脏卡表队列dirty card queue先**保存被其他区域引用的关系**，因为复制算法后地址会发生改变，导致引用会发生改变
> - 处理引用：空Eden会被记录到空闲列表中，等待下一次分配

G1在YGC的同时会“**初始标记**”：标记GC Roots能直接关联的对象。



##### YGC + 老年代并发标记过程

- **初始标记**：标记从根节点直接可达的对象。STW，并且会触发一次年轻代GC。
- **根区域扫描** (Root Region Scanning)：G1 GC扫描Survivor区“直接可达的老年代区域对象”，并标记被引用的对象。
- **并发标记**：从GC Roots对堆中的对象进行可达性分析，（并且记录程序运行中引用发生改变的部分）。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。

##### 混合回收 Mixed GC

老年代多的时候，> 45%，触发，回收部分老年代；YGC照旧

该阶段进行最后一次标记

- **重新标记**：修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，STW。
- **独占清理**：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域，STW。
- **并发清理**：标记复制，优先回收老年代中垃圾占比最多的region

##### 可选的过程：FullGC

导致FullGC的原因：

- 没有足够的空间来晋升（加大堆空间
- 并发处理过程完成前空间耗尽（调小触发GC周期的Java堆占用阈值
- 最大GC停顿时间太短，导致在规定时间间隔内无法完成垃圾回收



### 6、ZGC

https://blog.csdn.net/qq_41931364/article/details/107040928

jdk11开始支持

#### 目标

1》**支持TB级别**：根据官方文档来看，在Jdk11时ZGC可支持的最大内存为4TB，在jdk13可以支持16TB。

2》**最大停顿时间不超过10ms**：之所以能控制在10ms以下，是因为它的停顿时间主要跟Root扫描有关，而跟root数量和堆的大小没有关系。

3》**奠定未来GC特性的基础**。

4》**最坏的情况下吞吐量会下降15%**。





# JVM调优

[参考](https://blog.csdn.net/m0_68850571/article/details/123882068)

**对JVM内存的系统级的调优主要的目的是减少GC的频率和Full GC的次数。**

## 一、堆大小设置

**针对JVM堆的设置，一般可以通过-Xms -Xmx限定其最小、最大值，为了防止垃圾收集器在最小、最大之间收缩堆而产生额外的时间，通常把最大、最小设置为相同的值;**

```shell
-Xms: 初始堆大小 
-Xmx: 最大堆大小 
-XX:NewSize=n(或-Xmn): 设置年轻代大小 

-XX:NewRatio=n: 设置年轻代和年老代的比值.
如:为3,表示年轻代与年老代比值为1:3,年轻代占整个年轻代年老代和的1/4

-XX:SurvivorRatio=n: 年轻代中Eden区与两个Survivor区的比值.
注意Survivor区有两个.
如:3,表示Eden:Survivor=3:2, 一个Survivor区占整个年轻代的1/5 

-XX:MaxPermSize=n: 设置持久代大小

```



## 二、堆内存分配比例

年轻代和年老代将根据默认的比例（1：2）分配堆内存， 可以通过调整二者之间的比率NewRadio来调整二者之间的大小，也可以针对回收代。

比如年轻代，通过 -XX:newSize -XX:MaxNewSize来设置其绝对大小。同样，为了**防止年轻代的堆收缩**，我们通常会把-XX:newSize -XX:MaxNewSize设置为同样大小。

> 1）更大的年轻代必然导致更小的年老代，大的年轻代会延长普通GC的周期，但会增加每次GC的时间；小的年老代会导致更频繁的Full GC
>
> 2）更小的年轻代必然导致更大年老代，小的年轻代会导致普通GC很频繁，但每次的GC时间会更短；大的年老代会减少Full GC的频率



## 三、场景

> 业务高峰期，TP99耗时会变高，有明显的毛刺，通过排查发现内存使用率也会增大，然后再释放，于是怀疑是GC造成的。
>
> 观察GC情况，大概每5分钟，GC55次，峰值最高达220次；FullGC频繁，每五分钟0.5次，最高8次，已经很恐怖了。
>
> 那么问题在于FullGC频繁，而且YoungGC峰值高。

FullGC频繁，那么会触发STW，导致系统停顿，这个可能是TP99耗时上升的主要原因。由于并发很高，YoungGC频繁。

由于并发高，YoungGC频繁，那么可能造成，有些本该在YoungGC回收的对象，没有回收成功，直接进入了老年代，导致老年代出发FullGC。
