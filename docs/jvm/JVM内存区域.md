# JVM内存区域

> 栈管运行，堆管存储

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202203301347028.png" alt="image-20220330134754626" style="zoom:40%;" />

**线程私有区**【程序计数器、虚拟机栈（Java栈）、本地方法栈】

- 生命周期与线程相同, 依赖用户线程的启动/结束，而创建/销毁在 Hotspot VM 内

**线程共享区**【Java堆（堆空间）、方法区】

- 随虚拟机的启动/关闭而创建/销毁

**直接内存**【不受 JVM GC 管理】

- 不是 JVM 运行时数据区的一部分，但 I/O 可以使用 Native 函数直接分配堆外内存
- 直接内存并不是虚拟机运行时数据区的一部分，也不是Java 虚拟机规范中定义的内存区域。

> 在JDK1.4 中新加入了NIO(New Input/Output)类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。
>
> 这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。 
>
> 本机直接内存的分配不会受到 Java 堆大小的限制，受到本机总内存大小限制。 配置虚拟机参数时，不要忽略直接内存防止出现 OutOfMemoryError 异常。

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202203301115606.png" alt="image-20220330111510231" style="zoom: 33%;" />

<br>

栈：方法中的局部变量。

堆：new出来的对象。

方法区：.class相关信息，方法的信息。

## 一、程序计数器 PC寄存器

- 当前线程所执行的字节码的行号（地址）指示器，方便时间片结束后再次回来可以继续执行
- 唯一一个没有规定 OOM（OutOfMemoryError）的区域

<br>

## 二、虚拟机栈（Java栈）

> 存放`局部变量`
>
> - 8种基本数据类型
>
> - 引用数据类型的`引用`

异常：StackOverflow；OOM

栈帧弹出：函数返回或抛出异常

### 1、总体结构

描述java方法执行的内存模型，每个方法在执行的时候都会创建一个栈帧（Stack Frame）

参与方法的调用与返回

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202203301118092.png" alt="image-20220330111823493" style="zoom: 33%;" />

#### 2、栈帧

- 栈中`存储数据的基本单位`，一个栈帧对应一个方法

#### 栈帧存储的数据

方法在本次执行过程中所用到的局部变量、动态链接、方法出口等信息。栈帧中主要保存3 类数据：

- 本地变量（Local Variables）：输入参数和输出参数以及方法内的变量，**局部变量**。
- 栈操作（Operand Stack）：记录出栈、入栈的操作。
- 栈帧数据（Frame Data）：包括类文件、方法等等。

#### 结构

- **局部变量表**：定义为一个数字数组，存储方法参数和方法体内声明的`局部变量`
	- 其大小是编译期确定下来的
	- 8种基本数据类型、引用类型的引用（reference）、returnAdress类型
	- 都是数
- **操作数栈**（表达式栈）：保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间
- **动态链接**（指向运行时常量池中方法的引用）
	- 字节码文件中，所有变量和方法引用都作为符号引用保存在class常量池中
	- 动态链接就是为了将这些符号引用转换为调用方法的直接引用
- **方法返回地址**（方法正常退出或者异常退出的定义）
- 一些附加信息：例如对程序调试提供支持的信息

### 2、面试题

1. 调整栈的大小，就能保证不出现溢出吗？不能
2. 分配的栈内存越大越好吗？不是
3. 垃圾回收会涉及虚拟机栈吗？不会
4. 方法中定义的局部变量是否线程安全？

  - 一个线程安全，多个线程且不考虑同步问题会存在安全问题

<br>

## 三、本地方法栈

>虚拟机栈为 Java 方法服务，而本地方法栈为 Native 方法服务。

`HotSpot VM 将本地方法栈和虚拟机栈合二为一`

<br>

## 四、堆

> **TIP**：**new 的都在堆中**
>
> 创建的`实例对象实体`和`数组`都保存在堆中，也是 GC 的重要区域
>
> 实例变量
>
> NOTE：静态引用对应的`对象实体`也始终都在堆中
>
> 数组也是new出来的

1.8后加上`字符串池`和`静态变量（引用名）`

所有线程共享 Java 堆，但是还可以划分`线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）`

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202203301316327.png" alt="image-20220330131644568" style="zoom:40%;" />

> 分代是为了**优化GC性能**
>
> - 不同对象生命周期不同
> - Eden区主要是生命周期很短的对象，经常GC
> - 老年代主要是生命周期很长的对象，不经常GC
> 	- 例如：IOC容器对象、线程池对象、数据库连接池对象等等
> - 幸存者区作为二者之间的过渡地带



### 1、新生代young

- **Eden**：Java 新对象的出生地
	- `如果新创建的对象占用内存很大，则直接分配到老年代`
	- 当 Eden 内存不够的时候会触发 MinorGC，对新生代区进行 GC
- **ServivorFrom**：上一次 GC 的幸存者，作为这一次 GC 的被扫描者
- **ServicorTo**：保留了一次 MinorGC 过程中的幸存者
	- to 和 from 不是固定的
- **MinorGC** 的过程（复制 -> 清空 -> 互换，复制算法）
	- eden、from 中存活的对象复制到 to，年龄 + 1
		- to 满了就直接进 old 
		- 年龄到了15，即进行了15次 GC，进 old
	- 清空 eden、from 中的对象
	- to 和 from 互换指针，即原 to 成为下一次 GC 的 from

> 复制必交换，谁空谁为 to
>
> QA：为什么有两个survivor区？复制算法，避免碎片化

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202203310942440.png" alt="image-20220331094237355" style="zoom:50%;" />

### 2、老年代old

old 中的对象比较稳定，Major GC 不会频繁执行

MajorGC 采用标记清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。MajorGC 的耗时比较长，因为要扫描再回收。MajorGC 会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的时候，就会抛出 OOM（Out of Memory）异常。

> **TIP**
>
> Minor GC：清理 young
>
> Major GC：清理 old
>
> Full GC：清理整个堆空间
>
> 有时FGC和Major GC说的是一个

<br>

### 3、TLAB（Thread Local Allocation Buffer，TLAB）

线程私有缓存区，在Eden区分配（`1%`），但其他线程也可以访问，只是不需要加锁了，也可以避免了线程安全问题

JVM 将 TLAB 作为内存分配的首选

<br>

### 4、堆是分配对象存储的唯一选择吗？不是

如果经过`逃逸分析（Escape Analysis）`后发现，一个对象并没有逃溢出方法的话，那么就**可能被优化成栈上分配**。

如何将堆上的对象分配到栈，需要使用逃逸分析手段

逃逸分析：

- 一个对象在方法中被定义后，只在方法内部使用，则认为没有逃逸
- 一个对象在方法中被定义后，被外部方法所引用，则认为发生逃逸
	- 如作为调用参数传递到其他地方
	- `成员变量赋值`、`方法返回值`、`实例引用传递`

>快速判断是否发生了逃逸，看 new 的**对象实体**是否有可能在方法外被调用
>
>开发中能使用局部变量的，就不要使用在方法外定义。

### 5、逃逸分析之代码优化

#### 栈上分配

> 将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。

#### 同步省略

> 如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。

#### 标量替换/分离对象

> 有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分(或全部)可以不存储在内存，而是存储在CPU寄存器中。

**标量(Scalar)** 是指**一个无法再分解成更小的数据的数据**。Java中的原始数据类型就是标量。

还可以分解的数据叫做**聚合量(Aggregate)**，Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207021636657.png" alt="20200604133852140"  />

**Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个标量了**。那么标量替换有什么好处呢?就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。标量替换为**栈上分配**提供了很好的基础。

<br>

## 五、方法区

### 1、存放内容（类信息、字节码信息、代码片段）

- 类(型)信息：类class、枚举enum、接口interface、注解annotation
	- 类型的全名：包名.类名
	- 父类的完整有效名
	- 修饰符
	- 直接接口的一个有序列表
- 域(Field)信息、方法信息
- 静态变量/类变量（`引用名`）：non-final的类变量（`1.7及之后被移入堆`）
- 运行时常量池（`其中的字符串常量池StringTable在1.7及之后移入了堆`）
- 即时编译器编译后的代码缓存

> **TIP**：全局常量 static final
>
> 全局常量在编译时就会被分配

### 2、概念

- 标准层面：方法区（Method Area）
- 具体实现层面：
	- ≤1.7 永久代（PermGen）：名义上属于堆，实现上不属于堆
		- 1.7 中就已经将`字符串常量池StringTable和静态变量移入堆中`了
	- ≥1.8 元空间（MetaSpace）
		- 元空间使用本地内存
		- 类的元数据（描述代码间关系联系的数据）存入 native memory

<br>

### 3、永久代为什么被元空间替换？

1. 为永久代设置空间大小是很难确定的
2. 堆永久代进行调优很困难

### 4、StringTable为什么调整

永久代回收效率低，在FGC的时候才会触发，会导致StringTable回收效率不高，而开发中会有大量的字符串被创建，回收效率低会导致永久代内存不足。当到堆中，能及时回收内存。

### 5、方法区的垃圾回收

主要针对两部分

- 常量池中废弃的常量
- 不再使用的类型

永久代也是会有垃圾回收的

<br>

## Java栈、堆和方法区的关系

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202203301255028.png" alt="image-20220330125507742" style="zoom: 33%;" />

```java
class Test {
    static Person staticPer = new Person();
    Person instancePer = new Person();
    void foo() {
        Person localPer = new Person();
    }
}
/*
	new Person()	无论什么情况始终都在堆中
	staticPer		静态变量：≤1.6方法区，≥1.7堆
	instancePer		实例变量：随着Test的对象实例存在堆
	localPer		局部变量：存在foo()方法栈帧的局部变量表
*/
```

## 栈和堆的问题***

### 1、栈溢出的情况 StackOverflowError

- 大量递归
- 过多的全局变量
- 数组、List、map数据是否过大

- 通过-Xss设置栈的大小；OOM

### 2、内存溢出的情况OOM

- 内存溢出是由于**没被引用的对象（垃圾）过多造成JVM没有及时回收**，导致的内存溢出。
- 是否应用中的**类中和引用变量过多使用了Static修饰** 如public staitc Student s；
- 是否应用中使用了大量的递归（**递归中有新建对象**）
- 检查是否**有数组，List，Map中存放的是对象的引用**，因为这些引用会让对应的对象不能被释放
- 检查是否使用了“非字面量字符串进行 + ”的操作。因为 String 类的内容是不可变的，每次运行 " + " 就会产生新的对象，如果过多会造成新 String 对象过多，从而导致 JVM 没有及时回收而出现内存溢出。

```java
String s1 = "My name";
String s2 = "is";
String s3 = "xuwei";
String str = s1 + s2 + s3 +.........;
// 这是会容易造成内存溢出的

String str =  "My name" + " is " + " xuwei" 
    + " nice " + " to " + " meet you"; 
// 但是这种就不会造成内存溢出。
// 因为这是”字面量字符串“，在运行"+"时就会在编译期间运行好。
// 不会按照JVM来执行的。
```

### 3、内存泄漏

内存泄露是指一个不再被程序使用的对象或变量一直被占据在内存中。

内存泄漏的堆积会导致内存溢出。

情况：长生命周期的对象持有短生命周期对象的引用，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收。

- 缓存系统，加载了一个对象放在缓存中（例如一个全局map对象中），然后一直不再使用它，但是仍被map对象引用。
- 一个外部类的实例对象返回一个内部类的实例对象，外部类不再使用，但是内部类仍在使用，此时外部类实例对象仍不能回收。

<br>