### 案例一：循环等待

出现原因：一个用户A 访问表A（锁住了表A），然后又访问表B；另一个用户B 访问表B（锁住了表B），然后企图访问表A；这时用户A由于用户B已经锁住表B，它必须等待用户B释放表B才能继续，同样用户B要等用户A释放表A才能继续，这就死锁就产生了。

解决方法：

- 走索引，缩小锁的范围；
- 按照同资源访问顺序进行处理。（）



### 案例二：间隙锁和插入意向锁冲突，循环等待

有个业务主要逻辑就是新增订单、修改订单、查询订单等操作。然后因为订单是不能重复的，所以当时在新增订单的时候做了幂等性校验，做法就是在新增订单记录之前，先通过 `select ... for update` 语句查询订单是否存在，如果不存在才插入订单记录。

当业务量很大的时候，就可能会出现死锁。

建了一张订单表，其中 id 字段为主键索引，order_no 字段普通索引，也就是非唯一索引：

```sql
CREATE TABLE `t_order` (
  `id` int NOT NULL AUTO_INCREMENT,
  `order_no` int DEFAULT NULL,
  `create_date` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `index_order` (`order_no`) USING BTREE
) ENGINE=InnoDB ;
```

已经存在6条记录，order_no{1001,1002,1003,1004,1005,1006}

假设这时有两事务，一个事务要插入订单 1007 ，另外一个事务要插入订单 1008，因为需要对订单做幂等性校验，所以两个事务先要查询该订单是否存在，不存在才插入记录，过程如下：

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202208271007525.png" alt="图片" style="zoom: 50%;" />

两个事务都陷入了等待状态（前提没有打开死锁检测），也就是发生了死锁，因为都在相互等待对方释放锁。

这里在查询记录是否存在的时候，使用了 `select ... for update` 语句，目的为了防止事务执行的过程中，有其他事务插入了记录，而出现幻读的问题。

---

如果没有使用 `select ... for update` 语句，而使用了单纯的 select 语句，如果是两个订单号一样的请求同时进来，就会出现两个重复的订单，有可能出现幻读，如下图：

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202208271009946.png" alt="图片" style="zoom: 50%;" />

> 行锁的释放时机是在事务提交（commit）后，锁就会被释放，并不是一条语句执行完就释放行锁。

---

回来。

```sql
select id from t_order where order_no = 1007 for update;
select id from t_order where order_no = 1008 for update;
```

order_no不是唯一索引，所以锁是间隙锁，并且因为没有1007和1008记录，所以锁范围是**`(1006, +∞)`**。

因为当我们执行以下插入语句时，会在插入间隙上再次获取插入意向锁。

```sql
Insert into t_order (order_no, create_date) values (1007, now());
```

**插入意向锁与间隙锁是冲突的，所以当其它事务持有该间隙的间隙锁时，需要等待其它事务释放间隙锁之后，才能获取到插入意向锁。而间隙锁与间隙锁之间是兼容的，所以所以两个事务中 `select ... for update` 语句并不会相互影响**。

案例中的事务 A 和事务 B 在执行完后 `select ... for update` 语句后都持有范围为`(1006,+∞）`的间隙锁，而接下来的插入操作为了获取到插入意向锁，都在等待对方事务的间隙锁释放，于是就造成了循环等待，导致死锁。

### 案例三：索引不当，导致全表扫描

如果在事务中执行了一条不满足条件的语句，执行全表扫描，把行级锁上升为表级锁，多个这样的事务执行后，就很容易产生死锁和阻塞。类似的情况还有当表中的数据量非常庞大而索引建的过少或不合适的时候，使得经常发生全表扫描，最终应用系统会越来越慢，最终发生阻塞或死锁。

解决方法：对SQL语句进行分析，对于有全表扫描的SQL语句，建立相应的索引进行优化。

